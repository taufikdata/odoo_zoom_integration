

=== FILE: ./__init__.py ===
from . import models,controllers

=== FILE: ./static/src/html/index.xml ===
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <template id="meeting_rooms_html" name="Meeting Rooms HTML">
        <t t-name="meeting_rooms.meeting_rooms_html">
            <html lang="en">
                <head>
                    <meta charset="utf-8"/>
                    <meta name="viewport" content="width=device-width, initial-scale=1"/>
                    <title>Meeting Rooms Create Calendar</title>

                    <!-- IMPORTANT: jangan self-closing untuk script -->
                    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
                    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
                    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

                    <!-- CSS: jangan pakai text/scss langsung -->
                    <link rel="stylesheet" href="/meeting_rooms/static/src/css/index.css"/>
                    
                    <!-- Module JS -->
                    <script type="text/javascript" src="/meeting_rooms/static/src/js/index.js"></script>
                </head>

                <body>
                    <!-- Debug marker: kalau ini tampil, berarti halaman kebuka -->
                    <div style="font-family: Arial, sans-serif; font-size: 12px; padding: 10px; color: #555;">
                        Generating calendar invitation...
                    </div>

                    <!-- Debug marker in console -->
                    <script type="text/javascript">
                        console.log("[meeting_rooms] /create-icalendar page loaded");
                    </script>

                    <input type="hidden" id="start_date" t-att-value="start_date"/>
                    <input type="hidden" id="end_date" t-att-value="end_date"/>
                    <input type="hidden" id="subject" t-att-value="docs.subject"/>
                    <input type="hidden" id="room_location" t-att-value="docs.room_location.name"/>
                    <input type="hidden" id="description" t-att-value="docs.description"/>
                    <input type="hidden" id="reminder" t-att-value="docs.calendar_alarm.duration"/>
                    <input type="hidden" id="attendee" t-att-value="attendee"/>
                    <input type="hidden" id="user_email" t-att-value="request.env.user.email"/>
                    <input type="hidden" id="user_name" t-att-value="request.env.user.display_name"/>
                    <input type="hidden" id="meeting_id" t-att-value="docs.id"/>
                    <input type="hidden" id="create_date" t-att-value="docs.create_date"/>
                    <input type="hidden" id="write_date" t-att-value="docs.write_date"/>
                    <input type="hidden" id="version" t-att-value="docs.version"/>
                    <input type="hidden" id="roomTZ" t-att-value="host_tz_name"/>
                    <input type="hidden" id="tzOffset" t-att-value="docs.room_location.tz_offset"/>
                </body>
            </html>
        </t>
    </template>
</odoo>


=== FILE: ./__manifest__.py ===
{
    'name': "Meeting System (Host TZ)",

    'summary': """
        Short (1 phrase/line) summary of the module's purpose, used as
        subtitle on modules listing or apps.openerp.com""",

    'tag': """
        Long tag of module's purpose
    """,

    'author': "Alam",
    'website': "https://www.alamkamajana.com",

    # Categories can be used to filter modules in modules listing
    # Check https://github.com/odoo/odoo/blob/13.0/odoo/addons/base/data/ir_module_category_data.xml
    # for the full list
    'category': 'Uncategorized',
    'version': '0.1',

    # any module necessary for this one to work correctly
    'depends': ['base', 'calendar', 'mail', 'contacts', 'website'],

    'external_dependencies': {
        'python': ['requests', 'pytz', 'urllib3'],
    },

    # always loaded
    'data': [
        'security/meeting_security.xml',
        'security/ir.model.access.csv',
        'views/view.xml',
        'views/virtual_room.xml',
        'views/meeting_event_view.xml',
        'views/booking_link_view.xml',
        'views/meeting_rooms_ext_view.xml',
        'static/src/html/index.xml',
        # 'data/data_sync.xml',
        'data/cron_job.xml',
        'views/portal_templates.xml',
    ],

}


=== FILE: ./views/booking_link_view.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    
    <record id="view_meeting_booking_link_form" model="ir.ui.view">
        <field name="name">meeting.booking.link.form</field>
        <field name="model">meeting.booking.link</field>
        <field name="arch" type="xml">
            <form>
                <header>
                    <button name="action_regenerate_token" 
                            string="Regenerate Token" 
                            type="object" 
                            confirm="Link lama akan mati. Lanjutkan?" 
                            class="btn-warning"
                            attrs="{'invisible': [('is_current_user', '=', False), ('is_admin', '=', False)]}"/>
                </header>
                <sheet>
                    <div class="oe_title">
                        <label for="name" class="oe_edit_only"/>
                        <h1><field name="name" placeholder="e.g. Link for VIP Clients"/></h1>
                    </div>
                    <group>
                        <field name="is_current_user" invisible="1"/>
                        <field name="is_admin" invisible="1"/>
                        <field name="create_date" invisible="1"/>
                        
                        <group>
                            <field name="user_id" 
                                attrs="{'readonly': [('is_admin', '=', False), ('create_date', '!=', False)]}" 
                                domain="[('share', '=', False)]"
                                options="{'no_create': True, 'no_open': True}"/>
                                
                            <field name="active" widget="boolean_toggle" 
                                attrs="{'readonly': [('is_current_user', '=', False), ('is_admin', '=', False)]}"/>
                        </group>
                        <group>
                            <field name="booking_url" widget="CopyClipboardChar" readonly="1"/>
                            <field name="token" groups="base.group_no_one"/>
                        </group>
                    </group>
                    
                    <div class="alert alert-info" role="alert" attrs="{'invisible': [('is_current_user', '=', False), ('is_admin', '=', False)]}">
                        Ini link booking aktif. Share kepada tamu.
                    </div>
                    
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_meeting_booking_link_kanban" model="ir.ui.view">
        <field name="name">meeting.booking.link.kanban</field>
        <field name="model">meeting.booking.link</field>
        <field name="arch" type="xml">
            <kanban class="o_kanban_mobile o_kanban_dashboard">
                <field name="name"/>
                <field name="user_id"/>
                <field name="booking_url"/>
                <field name="active"/>
                <field name="is_current_user"/>
                <field name="is_admin"/> 
                <templates>
                    <t t-name="kanban-box">
                        <t t-if="record.is_current_user.raw_value or record.is_admin.raw_value">
                            <div class="oe_kanban_global_click oe_kanban_card p-3">
                                <t t-call="kanban-content"/>
                            </div>
                        </t>
                        
                        <t t-else="">
                            <div class="oe_kanban_card p-3" style="cursor: default;">
                                <t t-call="kanban-content"/>
                            </div>
                        </t>
                    </t>

                    <t t-name="kanban-content">
                        <div class="d-flex flex-column h-100">
                            <div class="mb-2 d-flex justify-content-between align-items-start">
                                <div class="text-truncate pr-2">
                                    <strong style="font-size: 1.1em; color: #212529;">
                                        <field name="name"/>
                                    </strong>
                                    <div class="text-muted small mt-1">
                                        <i class="fa fa-user-circle mr-1"/> <field name="user_id"/>
                                    </div>
                                </div>
                                <t t-if="record.is_current_user.raw_value">
                                    <span class="badge badge-pill badge-info">My Link</span>
                                </t>
                            </div>

                            <div class="o_form_view my-3 w-100">
                                <div class="o_group">
                                    <field name="booking_url" widget="CopyClipboardChar" class="w-100"/>
                                </div>
                            </div>

                            <div class="mt-auto pt-2 border-top d-flex justify-content-between align-items-center">
                                <span class="text-muted small">Status Link</span>
                                <field name="active" widget="boolean_toggle" attrs="{'readonly': [('is_current_user', '=', False), ('is_admin', '=', False)]}"/>
                            </div>
                        </div>
                    </t>
                </templates>
            </kanban>
        </field>
    </record>

    <record id="action_meeting_booking_link" model="ir.actions.act_window">
        <field name="name">All Booking Links</field>
        <field name="res_model">meeting.booking.link</field>
        <field name="view_mode">kanban,tree,form</field> 
    </record>

    <record id="action_edit_my_booking_link_server" model="ir.actions.server">
        <field name="name">Edit My Booking Link</field>
        <field name="model_id" ref="model_meeting_booking_link"/>
        <field name="state">code</field>
        <field name="code">
            action = model.action_open_my_link()
        </field>
    </record>

    <menuitem id="menu_open_my_link"
              name="Edit My Booking Link"
              parent="menu_meeting_rooms"
              action="action_edit_my_booking_link_server"
              sequence="10"/>

    <menuitem id="menu_meeting_booking_link" 
              name="Booking Links List" 
              parent="menu_meeting_rooms" 
              action="action_meeting_booking_link" 
              sequence="20"/>

</odoo>

=== FILE: ./views/meeting_event_view.xml ===
<?xml version="1.0" encoding="UTF-8"?>
<odoo>

    <record id="meeting_event_calendar_view" model="ir.ui.view">
        <field name="name">meeting_event_calendar_view</field>
        <field name="model">meeting.event</field>
        <field name="arch" type="xml">
            <calendar string="Meeting Date"
                      date_start="start_date"
                      date_stop="end_date"
                      mode="day"
                      quick_add="False"
                      color="state">
                <field name="room_location_ids"/>
                <field name="subject"/>
                <field name="start_date"/>
                <field name="end_date"/>
                <field name="attendee"/>
                <field name="state"/>
            </calendar>
        </field>
    </record>

    <record id="meeting_event_tree_view" model="ir.ui.view">
        <field name="name">meeting_event_tree_view</field>
        <field name="model">meeting.event</field>
        <field name="arch" type="xml">
            <tree string="Meeting Event">
                <field name="subject"/>
                <field name="room_location_ids" widget="many2many_tags"/>
                <field name="virtual_room_id" optional="show"/>
                <field name="start_date"/>
                <field name="end_date"/>
                <field name="attendee" widget="many2many_tags"/>
                <field name="state"/>
                <button name="unlink" string="Delete" class="btn-danger fa-trash-o" type="object"/>
            </tree>
        </field>
    </record>

        <record id="action_confirm_internal" model="ir.actions.server">
        <field name="name">Confirm Meeting (Internal)</field>
        <field name="model_id" ref="model_meeting_event"/>
        <field name="state">code</field>
        <field name="code">records.sudo().action_confirm()</field>
        </record>

        <record id="meeting_event_form_view" model="ir.ui.view">
        <field name="name">meeting_event_form_view</field>
        <field name="model">meeting.event</field>
        <field name="arch" type="xml">
            <form string="Meeting Event">
            <header>
                <button name="%(meeting_rooms.action_confirm_internal)d" 
                    type="action" 
                    states="draft" 
                    string="Confirm" 
                    class="btn-primary"/>
                    
                <button name="action_generate_virtual_link" 
                    type="object" 
                    string="Generate Meeting Link" 
                    class="oe_highlight"
                    icon="fa-video-camera"
                    attrs="{'invisible': ['|', '|', ('virtual_room_id', '=', False), ('state', '!=', 'confirm'), ('zoom_id', '!=', False)]}"/>

                <button name="action_get_ai_summary" 
                    type="object" 
                    string="Get AI Summary" 
                    class="oe_highlight"
                    icon="fa-magic"
                    attrs="{'invisible': ['|', '|', ('virtual_room_id', '=', False), ('state', '!=', 'confirm'), ('zoom_id', '=', False)]}"/>

                <button name="action_cancel" 
                    type="object" 
                    states="confirm" 
                    string="Cancel" 
                    class="btn-secondary"
                    confirm="WARNING: Are you sure you want to cancel this Event? This action will automatically cancel ALL connected Meeting Rooms."/>

                <button name="action_draft" 
                    type="object" 
                    states="cancel" 
                    string="Set To Draft" 
                    class="btn-secondary"
                    confirm="WARNING: Setting Event to Draft will also set ALL Meeting Rooms to Draft. Continue?"/>
                            
                <field name="state" widget="statusbar" statusbar_visible="draft,confirm,cancel"/>
            </header>

                <sheet>
                    <div class="oe_button_box" name="button_box">
                        <button name="%(meeting_rooms.action_meeting_booking_link)d" 
                                type="action" 
                                class="oe_stat_button" 
                                icon="fa-link" 
                                string="Booking Links">
                        </button>
                        
                        <button name="open_zoom_link"
                                type="object"
                                class="oe_stat_button"
                                icon="fa-video-camera"
                                string="Join Meeting"
                                attrs="{'invisible': [('zoom_link', '=', False)]}">
                        </button>
                    </div>
                    <group>
                        <group>
                            <field name="subject" required="1"/>
                            <field name="room_location_ids" widget="many2many_tags"/>

                            <field name="guest_partner_id" widget="res_partner_many2one" context="{'show_email': True}"/>
                            <field name="guest_emails" placeholder="john@example.com, jane@example.com"/>
                            
                            <field name="virtual_room_id" 
                                   widget="selection" 
                                   string="Virtual Room Provider" 
                                   placeholder="Leave empty for offline meeting"/>
                            
                            <field name="description"/>
                            <field name="calendar_alarm"
                                   domain="[('interval','=','minutes'),('alarm_type','=','notification')]"
                                   widget="selection"/>
                            <field name="recurrency"/>
                        </group>
                        <group>
                            <field name="start_date"/>
                            <field name="end_date"/>

                            <field name="attendee"
                                   options="{'no_create_edit': True,'no_create': True}"
                                   widget="many2many_tags"
                                   domain="[('login','ilike','@Tripper.com'),('id','!=',uid)]"/>
                            <button name="create_calendar_web" type="object" string="Send Email &amp; Download ICS"/>
                        </group>
                    </group>

                    <group>
                        <field name="create_uid" string="Initiator"/>
                        <field name="create_date" string="Create Date"/>
                    </group>

                    <notebook>
                        <page string="Room Bookings">
                            <field name="meeting_room_ids">
                                <tree string="Generated Bookings" 
                                      decoration-danger="state=='cancel'" 
                                      decoration-info="state=='draft'" 
                                      decoration-success="state=='confirm'">
                                    <field name="room_location"/>
                                    <field name="start_date"/>
                                    <field name="end_date"/>
                                    <field name="state" widget="badge"/>
                                </tree>
                            </field>
                        </page>

                        <page string="Virtual Meeting Info" attrs="{'invisible': [('zoom_id', '=', False)]}">
                            
                            <group string="Connection Details">
                                <group>
                                    <field name="zoom_id" string="Meeting ID" readonly="1" class="oe_inline" style="font-weight: bold; font-size: 1.2em;"/>
                                </group>
                                <group>
                                    <field name="zoom_link" widget="url" string="Join URL"/>
                                    <field name="zoom_start_url" widget="url" string="Start URL (Host Only)" groups="base.group_system"/>
                                </group>
                            </group>

                            <separator string="Invitation Details"/>
                            <p class="text-muted">
                                Copy text below to send via WhatsApp or Email manually.
                            </p>
                            <field name="zoom_invitation" nolabel="1" style="background-color: #f9f9f9; padding: 10px; border-radius: 5px; font-family: monospace;"/>

                            <separator string="AI Summary Result"/>
                            <field name="ai_summary"/>
                        </page>

                        <page attrs="{'invisible': [('recurrency', '=', False)]}" string="Recurrence">
                            <group>
                                <group>
                                    <field name="rrule_type" attrs="{'required': [('recurrency', '=', True)]}"/>
                                </group>
                                <group>
                                    <field name="final_date" attrs="{'required': [('recurrency', '=', True)]}"/>
                                </group>
                            </group>
                        </page>

                        <page string="IT Settings" groups="base.group_system">
                            <group>
                                <group>
                                    <field name="version"/>
                                </group>
                                <group>
                                    <field name="calendar_file"/>
                                </group>
                            </group>
                        </page>
                    </notebook>
                </sheet>

                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers" groups="base.group_user"/>
                    <field name="message_ids" widget="mail_thread"/>
                    <field name="activity_ids" widget="mail_activity"/>
                </div>
            </form>
        </field>
    </record>

    <record model="ir.actions.act_window" id="action_meeting_event">
        <field name="name">Meeting Events</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">meeting.event</field>
        <field name="view_mode">calendar,tree,form</field>
    </record>

    <menuitem name="Meeting Events"
              id="menu_meeting_event"
              parent="meeting_rooms.menu_meeting_rooms"
              action="action_meeting_event"
              sequence="1"/> 

</odoo>

=== FILE: ./views/portal_templates.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <template id="portal_booking_template" name="Booking Page">
        <t t-call="web.login_layout">
            <style>
                body { background-color: #f3f4f6; }
                .calendly-card {
                    background: white; border-radius: 8px;
                    box-shadow: 0 4px 25px rgba(0,0,0,0.05);
                    max-width: 1000px; margin: 50px auto; min-height: 600px;
                }
                .time-slot-btn {
                    display: block; width: 100%; text-align: center; padding: 10px 0;
                    margin-bottom: 10px; border: 1px solid #3b82f6; color: #3b82f6;
                    border-radius: 4px; font-weight: 600; text-decoration: none;
                }
                .time-slot-btn:hover {
                    background-color: #3b82f6; color: white;
                }
            </style>

            <div class="container-fluid">
                <div class="calendly-card">
                    <div class="row h-100 g-0">
                        <div class="col-md-4 p-5 border-right text-center">
                            <img t-attf-src="/book/avatar/#{token}" 
                                 style="width:80px; height:80px; border-radius:50%; object-fit: cover;" 
                                 alt="Host"/>
                            
                            <h4 class="mt-3"><t t-esc="host.name"/></h4>
                            <p class="text-muted">60 Min Meeting</p>
                        </div>
                        <div class="col-md-8 p-5">
                            <h3 class="font-weight-bold mb-4">Select Date &amp; Time (<span><t t-esc="tz_name"/></span>)</h3>
                            
                            <div class="row">
                                <t t-foreach="dates" t-as="day">
                                    <div class="col-md-4 mb-4">
                                        <div class="text-center font-weight-bold mb-2">
                                            <t t-esc="day['date_str']"/>
                                        </div>
                                        <t t-foreach="day['slots']" t-as="slot">
                                            <a t-attf-href="/booking/details?token=#{token}&amp;time_str=#{slot['val']}&amp;tz=" 
                                               class="time-slot-btn booking-slot-link"
                                               data-utc-time="#{slot['val']}">
                                                <span class="slot-time"><t t-esc="slot['time_str']"/></span>
                                            </a>
                                        </t>
                                        <t t-if="not day['slots']">
                                            <div class="text-center small text-muted">No slots</div>
                                        </t>
                                    </div>
                                </t>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <script><![CDATA[
                // Use host timezone only - no guest timezone conversion
                (function() {
                    // Slots already display in host timezone from backend
                    // No JavaScript conversion needed
                    console.log('Booking calendar loaded with host timezone');
                })();
            ]]></script>
        </t>
    </template>

    <template id="portal_booking_form_template" name="Booking Details">
        <t t-call="web.login_layout">
            <div class="container mt-5">
                <div class="card shadow-sm" style="max-width: 600px; margin: 0 auto;">
                    <div class="card-body p-4">
                        <h4 class="mb-4">Enter Meeting Details</h4>
                        <form action="/booking/submit" method="POST" id="booking-form">
                            <input type="hidden" name="csrf_token" t-att-value="request.csrf_token()"/>
                            <input type="hidden" name="token" t-att-value="token"/>
                            
                            <input type="hidden" name="time_str" t-att-value="time_str"/>
                            
                            <div class="form-group">
                                <label class="font-weight-bold text-muted small">Selected Time</label>
                                <input type="text" id="selected-time-display" class="form-control" readonly="readonly" t-att-value="display_time" 
                                       style="background-color: #e9ecef; font-weight:bold; color:#2c3e50;"/>
                            </div>

                            <div class="form-group">
                                <label class="font-weight-bold text-muted small">Your Name</label>
                                <input type="text" id="booking-name" name="name" class="form-control" required="required" t-att-value="default_name" placeholder="John Doe"/>
                            </div>

                            <div class="form-group">
                                <label class="font-weight-bold text-muted small">Your Email</label>
                                <textarea id="booking-email" name="email" class="form-control" required="required" rows="2" placeholder="john@example.com, jane@example.com"><t t-esc="default_email"/></textarea>
                                <small class="form-text text-muted">You can add multiple emails separated by commas, semicolons, or new lines.</small>
                            </div>

                            <div class="form-group">
                                <label class="font-weight-bold text-muted small">Topic / Subject (Optional)</label>
                                <input type="text" id="booking-subject" name="subject" class="form-control" placeholder="e.g. Project Discussion"/>
                            </div>
                            
                            <div class="mt-4">
                                <button type="submit" class="btn btn-primary btn-block" style="background-color: #00A09D; border: none; padding: 12px; font-weight:bold;">
                                    Confirm Booking
                                </button>
                            </div>
                        </form>
                        <script><![CDATA[
                            // No timezone conversion - use host timezone as-is
                            // 2. Form Validation & Confirmation
                            (function () {
                                var form = document.getElementById('booking-form');
                                if (!form) return;

                                function splitEmails(raw) {
                                    return (raw || '')
                                        .split(/[,;\n]+/)
                                        .map(function (e) { return e.trim(); })
                                        .filter(Boolean);
                                }

                                function isValidEmail(email) {
                                    if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) return false;
                                    var lower = email.toLowerCase();
                                    var gmailTypos = ['@gmail.ocm', '@gmail.con', '@gmail.co', '@gmail.cm', '@gmai.com', '@gmial.com', '@gmal.com', '@gamil.com'];
                                    for (var i = 0; i < gmailTypos.length; i++) {
                                        if (lower.endsWith(gmailTypos[i])) return false;
                                    }
                                    if (lower.endsWith('@gmail.com') || lower.endsWith('@googlemail.com')) {
                                        return /^(?!\.)[a-z0-9]+(?:\.[a-z0-9]+)*@(gmail\.com|googlemail\.com)$/.test(lower);
                                    }
                                    return true;
                                }

                                form.addEventListener('submit', function (e) {
                                    var name = (document.getElementById('booking-name').value || '').trim();
                                    var emailRaw = (document.getElementById('booking-email').value || '').trim();
                                    var subject = (document.getElementById('booking-subject').value || '').trim();
                                    var timeDisplay = (document.querySelector('input[readonly]') || {}).value || '';

                                    var emails = splitEmails(emailRaw);
                                    if (!emails.length) {
                                        alert('Email is required.');
                                        e.preventDefault();
                                        return;
                                    }

                                    var invalid = emails.filter(function (e) { return !isValidEmail(e); });
                                    if (invalid.length) {
                                        alert('Invalid email(s): ' + invalid.join(', '));
                                        e.preventDefault();
                                        return;
                                    }

                                    var confirmMessage =
                                        'Please confirm your booking details:\n\n' +
                                        'Name: ' + name + '\n' +
                                        'Email(s): ' + emails.join(', ') + '\n' +
                                        (subject ? ('Subject: ' + subject + '\n') : '') +
                                        'Time: ' + timeDisplay + '\n\n' +
                                        'Proceed with booking?';

                                    if (!window.confirm(confirmMessage)) {
                                        e.preventDefault();
                                    }
                                });
                            })();
                        ]]></script>
                    </div>
                </div>
            </div>
        </t>
    </template>
</odoo>

=== FILE: ./views/view.xml ===
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="mail_act_meeting_rooms_approval" model="mail.activity.type">
        <field name="name">Meeting Rooms</field>
        <field name="icon">fa-sun-o</field>
        <field name="res_model_id" ref="meeting_rooms.model_meeting_rooms"/>
    </record>

    <record id="meeting_rooms_calendar_view" model="ir.ui.view">
        <field name="name">meeting_rooms_calendar_view</field>
        <field name="model">meeting.rooms</field>
        <field name="arch" type="xml">
            <calendar string="Meeting Date" 
                      date_start="start_date" 
                      date_stop="end_date" 
                      mode="day" 
                      quick_add="False" 
                      event_open_popup="False"
                      color="room_location">
                <field name="room_location"/>
                <field name="subject"/>
                <field name="start_date"/>
                <field name="end_date"/>
                <field name="attendee"/>
                <field name="state"/>
            </calendar>
        </field>
    </record>

    <record id="meeting_rooms_tree_view" model="ir.ui.view">
        <field name="name">meeting_rooms_tree_view</field>
        <field name="model">meeting.rooms</field>
        <field name="arch" type="xml">
            <tree string="Meeting Room Booking" create="0" delete="0" edit="0">
                <field name="subject"/>
                <field name="room_location"/>
                <field name="start_date"/>
                <field name="end_date"/>
                <field name="attendee" widget="many2many_tags"/>
                <field name="description"/>
                <field name="state"/>
            </tree>
        </field>
    </record>

    <record id="meeting_rooms_from_view" model="ir.ui.view">
        <field name="name">meeting_rooms_from_view</field>
        <field name="model">meeting.rooms</field>
        <field name="arch" type="xml">
            <form string="Meeting Rooms Booking" create="0" delete="0" edit="0">
                <header>
                    <field name="state" widget="statusbar" statusbar_visible="draft,confirm,cancel"/>
                </header>
                <sheet>
                    <group>
                        <group>
                            <field name="subject"/>
                            <field name="room_location" widget="selection"/>
                            <field name="description"/>
                            <field name="calendar_alarm" widget="selection"/>
                            <field name="recurrency"/>
                        </group>
                        <group>
                            <field name="start_date"/>
                            <field name="end_date"/>
                            <field name="attendee" widget="many2many_tags"/>
                            <button name="create_calendar_web" type="object" string="Send Email"/>
                        </group>
                    </group>
                    <group>
                        <field name="create_uid" string="Initiator"/>
                        <field name="create_date" string="Create Date"/>
                    </group>
                    <notebook>
                        <page attrs="{'invisible': [('recurrency', '=', False)]}" string="Reccurent">
                            <group>
                                <field name="rrule_type"/>
                            </group>
                            <group>
                                <field name="final_date"/>
                            </group>
                        </page>
                        <page string="IT Settings" groups="base.group_system">
                            <group>
                                <field name="version"/>
                                <field name="calendar_file"/>
                            </group>
                        </page>
                    </notebook>
                </sheet>
                <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers" groups="base.group_user"/>
                    <field name="message_ids" widget="mail_thread"/>
                    <field name="activity_ids" widget="mail_activity"/>
                </div>
            </form>
        </field>
    </record>

    <record id="room_location_form_view" model="ir.ui.view">
        <field name="name">room.location.form.view</field>
        <field name="model">room.location</field>
        <field name="arch" type="xml">
            <form string="Room Booking">
                <sheet>
                    <group>
                        <group>
                            <field name="name"/>
                            <field name="location_address"/>
                            <field name="location_description"/>
                            <field name="active"/>
                        </group>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="room_location_tree_view" model="ir.ui.view">
        <field name="name">room_location.tree.view</field>
        <field name="model">room.location</field>
        <field name="arch" type="xml">
            <tree string="Room Locations">
                <field name="name"/>
                <field name="location_address"/>
                <field name="location_description"/>
            </tree>
        </field>
    </record>

    <record model="ir.actions.act_window" id="action_room_location">
        <field name="name">Room Locations</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">room.location</field>
        <field name="view_mode">tree,form</field>
    </record>

    <record model="ir.actions.act_window" id="action_meeting_rooms_readonly_final">
        <field name="name">Booked Rooms (Read Only)</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">meeting.rooms</field>
        <field name="view_mode">calendar,tree,form</field>
        <field name="context">{'create': False, 'delete': False, 'edit': False, 'no_quick_create': True}</field>
    </record>


    <menuitem name="Meeting System" id="menu_meeting_rooms" sequence="60"/>
    <record id="menu_meeting_rooms" model="ir.ui.menu">
        <field name="action" eval="False"/>
    </record>

    <menuitem name="Booked Rooms List" 
              id="menu_meeting_rooms_list_readonly" 
              parent="menu_meeting_rooms" 
              action="action_meeting_rooms_readonly_final" 
              sequence="100"/>
              
    <menuitem name="Room Locations" id="menu_room_locations" parent="menu_meeting_rooms" action="action_room_location" groups="approvals.group_approval_user" sequence="110"/>
    <menuitem id="menu_meeting_booking_link" name="Booking Links List" parent="menu_meeting_rooms" action="action_meeting_booking_link" sequence="120"/>

</odoo>

=== FILE: ./views/meeting_rooms_ext_view.xml ===
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <record id="meeting_rooms_form_ext_event" model="ir.ui.view">
        <field name="name">meeting.rooms.form.ext.event.link</field>
        <field name="model">meeting.rooms</field>
        <field name="inherit_id" ref="meeting_rooms.meeting_rooms_from_view"/>
        <field name="arch" type="xml">
            <xpath expr="//field[@name='subject']" position="after">
                <field name="meeting_event_id" invisible="1"/>
            </xpath>
        </field>
    </record>
</odoo>

=== FILE: ./views/virtual_room.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_virtual_room_form" model="ir.ui.view">
        <field name="name">virtual.room.form</field>
        <field name="model">virtual.room</field>
        <field name="arch" type="xml">
            <form string="Virtual Room Configuration">
                <header>
                    <button name="action_test_connection" 
                            string="Test API Connection" 
                            type="object" 
                            class="btn-secondary" 
                            icon="fa-plug"
                            attrs="{'invisible': [('provider', '=', 'google_meet')]}"/>
                </header>
                
                <sheet>
                    <div class="oe_title">
                        <label for="name" class="oe_edit_only"/>
                        <h1><field name="name" placeholder="e.g. Official Zoom Account"/></h1>
                    </div>

                    <!-- Basic Settings -->
                    <group>
                        <field name="active"/>
                        <field name="provider" widget="radio"/>
                        <field name="email" placeholder="host@company.com"/>
                    </group>

                    <separator string="API Configuration"/>

                    <!-- Zoom / Teams Credentials -->
                    <group attrs="{'invisible': [('provider', '=', 'google_meet')]}">
                        <group string="Credentials">
                            <field name="zoom_account_id" 
                                   string="Account ID (Zoom) / Tenant ID (Teams)" 
                                   attrs="{'required': [('provider', '!=', 'google_meet')]}"/>
                            <field name="zoom_client_id" 
                                   string="Client ID" 
                                   attrs="{'required': [('provider', '!=', 'google_meet')]}"/>
                            <field name="zoom_client_secret" 
                                   string="Client Secret" 
                                   password="True" 
                                   attrs="{'required': [('provider', '!=', 'google_meet')]}"/>
                        </group>
                    </group>

                    <!-- Google Meet Static Link -->
                    <group attrs="{'invisible': [('provider', '!=', 'google_meet')]}">
                        <group string="Meeting Link Configuration">
                            <field name="static_link" 
                                   string="Permanent Google Meet Link" 
                                   placeholder="https://meet.google.com/xxx-xxxx-xxx"
                                   attrs="{'required': [('provider', '=', 'google_meet')]}"/>
                        </group>
                        <div class="alert alert-info" role="alert">
                            <span><i class="fa fa-info-circle"></i> <strong>How to create a permanent Google Meet link:</strong></span>
                            <ol class="mt-2 mb-0">
                                <li>Go to <strong>meet.google.com</strong></li>
                                <li>Click <strong>"New meeting"</strong> â†’ <strong>"Create a meeting for later"</strong></li>
                                <li>Copy the meeting link (format: meet.google.com/xxx-xxxx-xxx)</li>
                                <li>Paste it in the field above</li>
                            </ol>
                            <p class="mt-2 mb-0"><strong>Note:</strong> This link will be reused for all meetings created with this Virtual Room.</p>
                        </div>
                    </group>
                </sheet>
            </form>
        </field>
    </record>

    <record id="view_virtual_room_tree" model="ir.ui.view">
        <field name="name">virtual.room.tree</field>
        <field name="model">virtual.room</field>
        <field name="arch" type="xml">
            <tree string="Virtual Rooms">
                <field name="name"/>
                <field name="provider"/>
                <field name="email"/>
                <field name="active"/>
            </tree>
        </field>
    </record>

    <record id="action_virtual_room" model="ir.actions.act_window">
        <field name="name">Virtual Room Accounts</field>
        <field name="res_model">virtual.room</field>
        <field name="view_mode">tree,form</field>
    </record>

    <menuitem id="menu_virtual_room" 
              name="Virtual Rooms" 
              parent="menu_meeting_rooms" 
              action="action_virtual_room" 
              sequence="30"/>
</odoo>

=== FILE: ./data/data_sync.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="0">
        <function model="meeting.rooms" name="action_sync_legacy_data"/>
    </data>
</odoo>

=== FILE: ./data/cron_job.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <record id="ir_cron_auto_delete_meeting_activities" model="ir.cron">
            <field name="name">Auto Delete Meeting Activities</field>
            <field name="model_id" ref="model_meeting_event"/>
            <field name="state">code</field>
            <field name="code">model._cron_auto_delete_activities()</field>
            <field name="user_id" ref="base.user_root"/>
            <field name="interval_number">1</field>
            <field name="interval_type">days</field>
            <field name="numbercall">-1</field> <field name="doall" eval="False"/>
            <field name="priority">5</field>
        </record>
    </data>
</odoo>

=== FILE: ./controllers/website.py ===
# -*- coding: utf-8 -*-
from datetime import datetime,date,timedelta
import json
from werkzeug.utils import redirect
from odoo import http
from odoo.http import request
import pytz
import base64


class MeetingRoomsWebsite(http.Controller):
    def _get_host_tz_name(self, meeting):
        event = getattr(meeting, 'meeting_event_id', False)
        if event and event.host_user_id and event.host_user_id.tz:
            return event.host_user_id.tz
        if meeting.create_uid and meeting.create_uid.tz:
            return meeting.create_uid.tz
        return 'UTC'

    def _convert_utc_to_tz(self, dt, tz_name):
        if not dt:
            return dt
        tz = pytz.timezone(tz_name or 'UTC')
        if dt.tzinfo is None:
            dt = pytz.utc.localize(dt)
        return dt.astimezone(tz)

    @http.route('/create-icalendar', auth='user', website=True)
    def create_icalendar(self, **kw):
        meeting_id = kw.get('id')
        meeting = request.env['meeting.rooms'].sudo().browse(int(meeting_id))
        attendee = []
        host_tz_name = self._get_host_tz_name(meeting)
        start_time = self._convert_utc_to_tz(meeting.start_date, host_tz_name)
        end_time = self._convert_utc_to_tz(meeting.end_date, host_tz_name)
        create_time = self._convert_utc_to_tz(meeting.create_date, host_tz_name)
        write_time = self._convert_utc_to_tz(meeting.write_date, host_tz_name)
        for user in meeting.attendee :
            if user.display_name and user.email :
                attendee.append({
                    "name" : user.display_name,"email" : user.email
                })
        vals = {
            'docs' : meeting,
            'attendee' : attendee,
            'start_date' : start_time,
            'end_date' : end_time,
            'create_date' : create_time,
            'write_date' : write_time,
            'host_tz_name': host_tz_name,

        }
        return request.render("meeting_rooms.meeting_rooms_html", vals)

    @http.route('/add-icalendar-file', type='http', auth='user', website=True, csrf=True)
    def add_calendar_file(self, **kw):
        file = kw.get("calendar")
        file_name = kw.get("calendar_name")
        meeting_id = int(kw.get("meeting_id"))
        files = base64.b64encode(file.read())
        attachment = None
        attachment_calendar = request.env['ir.attachment'].sudo().search(
            [('res_model', '=', 'meeting.rooms'), ('type', '=', 'binary'), ('res_field', '=', 'calendar_file'),
             ('res_id', '=', meeting_id)])
        if attachment_calendar:
            attachment_calendar.unlink()
            attachment = request.env['ir.attachment'].sudo().create({
                'name': file_name,
                'type': 'binary',
                'res_model': 'meeting.rooms',
                'res_field': 'calendar_file',
                'res_id': meeting_id,
                'res_name': file_name,
                'datas': files,
                'public': True
            })
        else:
            attachment = request.env['ir.attachment'].sudo().create({
                'name': file_name,
                'type': 'binary',
                'res_model': 'meeting.rooms',
                'res_field': 'calendar_file',
                'res_id': meeting_id,
                'res_name': file_name,
                'datas': files,
                'public': True
            })
        record = request.env['meeting.rooms'].sudo().browse(meeting_id)
        host_tz_name = self._get_host_tz_name(record)
        start_time = self._convert_utc_to_tz(record.start_date, host_tz_name)
        end_time = self._convert_utc_to_tz(record.end_date, host_tz_name)
        formatted_start_time = start_time.strftime('%b %d, %Y')
        start_time_hours = start_time.strftime('%H:%M')
        formatted_end_time = end_time.strftime('%b %d, %Y %H:%M')
        end_time_hours = end_time.strftime('%H:%M')
        duration = end_time - start_time
        meeting_hours, remainder = divmod(duration.total_seconds(), 3600)
        meeting_minutes, meeting_seconds = divmod(remainder, 60)
        meeting_hours_str = ""
        if meeting_hours > 0:
            meeting_hours_str = f"{int(meeting_hours)} hours "

        meeting_minutes_str = ""
        if meeting_minutes > 0:
            meeting_minutes_str = f"{int(meeting_minutes)} minutes"
        recipients = []
        recipients.append(record.create_uid.email)
        for user in record.attendee:
            recipients.append(user.email)
        recipients_email = ",".join(recipients)
        email_body = f"""
            Hi <b>Team</b>,<br/><br/>
            I hope this message finds you well. <b>{record.create_uid.name}</b> has invited you to the "{record.name}" meeting<br/><br/>
            <table border="0">
                <tbody>
                    <tr>
                        <td style="width:80px;">Date</td>
                        <td>: {formatted_start_time}</td>
                    </tr>
                    <tr>
                        <td>Time</td>
                        <td>: {start_time_hours} - {end_time_hours} ({host_tz_name}'s Time)</td>
                    </tr>
                    <tr>
                        <td>Duration</td>
                        <td>: {meeting_hours_str}{meeting_minutes_str}</td>
                    </tr>
                    <tr>
                        <td>Location</td>
                        <td>: {record.room_location.name}</td>
                    </tr>
                </tbody>
            </table>
            <br/>
            To accept or decline this invitation, click the attachment below.<br/><br/>
            """
        company_email = (record.company_id.email or request.env.company.email or request.env.user.email or '').strip()
        email_from = company_email if company_email else request.env.user.email
        email = request.env['mail.mail'].sudo().create({
            'subject': record.subject,
            'email_from': email_from,
            'email_to': recipients_email,
            'body_html': email_body

        })
        email.attachment_ids = attachment
        email.send()
        log = None
        if email.state == "sent":
            log = f"""
                    <b>Email Sent</b> <br/>
                    id : {email.id} <br/>
                    subject : {email.subject} <br/>
                    email to : {recipients_email} <br/>
                    body : {email.body_html} 

                """
        elif email.state == "exception":
            log = f"Email {email.id} Delivery Failed"
        else:
            log = f"Email Delivery {email.state}"
        record.message_post(body=log)
        data = {'url': attachment.local_url}
        return json.dumps(data)


=== FILE: ./controllers/booking_portal.py ===
# -*- coding: utf-8 -*-
from odoo import http, fields, _
from odoo.http import request
from datetime import datetime, timedelta, time
import pytz
import base64
import re
from werkzeug.utils import redirect
import logging

# Logger khusus untuk debugging
_logger = logging.getLogger(__name__)

class BookingPortal(http.Controller):

    # =========================================================================
    # 0. Host avatar endpoint
    # =========================================================================
    @http.route('/book/avatar/<string:token>', type='http', auth='public')
    def booking_avatar(self, token):
        link_obj = request.env['meeting.booking.link'].sudo().search([('token', '=', token)], limit=1)
        if not link_obj:
            return request.not_found()
        
        partner = link_obj.user_id.partner_id
        if not partner.image_128:
            return redirect('/web/static/img/placeholder.png')
            
        image_data = base64.b64decode(partner.image_128)
        headers = [
            ('Content-Type', 'image/png'), 
            ('Content-Length', len(image_data)),
            ('Cache-Control', 'max-age=3600, public')
        ]
        return request.make_response(image_data, headers)

    # =========================================================================
    # 1. Calendar page 
    # =========================================================================
    @http.route('/book/<string:token>', type='http', auth='public', website=True)
    def booking_calendar(self, token, **kw):
        _logger.info(f"\n\n=== [DEBUG START] OPENING CALENDAR PAGE ({token}) ===")
        
        link_obj = request.env['meeting.booking.link'].sudo().search([
            ('token', '=', token),
            ('active', '=', True)
        ], limit=1)

        if not link_obj:
            _logger.error("Token not found or inactive")
            return request.render('http_routing.404') 

        host_user = link_obj.user_id
        host_tz_name = host_user.tz
        
        _logger.info(f"HOST FOUND: {host_user.name} | TIMEZONE: {host_tz_name}")

        if not host_tz_name:
            return "ERROR: Host user does not have a timezone set."
        
        try:
            host_tz = pytz.timezone(host_tz_name)
        except:
            _logger.error(f"Invalid Timezone: {host_tz_name}")
            return f"ERROR: Invalid timezone '{host_tz_name}'."

        # Current time reference
        now_utc = datetime.now(pytz.utc)
        now_host = now_utc.astimezone(host_tz)
        
        _logger.info(f"NOW (UTC): {now_utc}")
        _logger.info(f"NOW (HOST): {now_host}")
        
        dates = []
        MeetingEvent = request.env['meeting.event'].sudo()

        # Generate next 6 days
        for i in range(6): 
            current_date_host = now_host.date() + timedelta(days=i)
            day_slots = []
            
            for hour in range(9, 17): 
                # 1. Create Timestamp in HOST TIMEZONE (e.g. 09:00 Europe/Brussels)
                slot_naive = datetime.combine(current_date_host, time(hour, 0, 0))
                slot_aware_host = host_tz.localize(slot_naive)
                
                # Skip past times
                if slot_aware_host < now_host:
                    continue

                # 2. Calculate UTC equivalent for DB check
                slot_aware_utc = slot_aware_host.astimezone(pytz.utc)
                end_aware_utc = slot_aware_utc + timedelta(hours=1)

                db_start = slot_aware_utc.replace(tzinfo=None)
                db_end = end_aware_utc.replace(tzinfo=None)

                # Check Availability
                domain = [
                    ('start_date', '<', db_end),
                    ('end_date', '>', db_start),
                    ('state', '=', 'confirm'),
                    ('attendee', 'in', [host_user.id])
                ]
                count_busy = MeetingEvent.search_count(domain)

                if count_busy == 0:
                    # KITA KIRIM WAKTU LOKAL (HOST) KE URL
                    # Supaya nanti di submit kita konversi ulang berdasarkan Host TZ
                    local_val = slot_naive.strftime('%Y-%m-%d %H:%M:%S')
                    
                    day_slots.append({
                        'time_str': f"{hour:02d}:00", 
                        'val': local_val
                    })

            if day_slots:
                dates.append({
                    'date_str': current_date_host.strftime('%A, %d %b'),
                    'slots': day_slots
                })

        _logger.info("=== [DEBUG END] CALENDAR RENDERED ===\n")
        return request.render('meeting_rooms.portal_booking_template', {
            'host': host_user,
            'dates': dates,
            'token': token,
            'tz_name': host_tz_name,
        })

    # =========================================================================
    # 2. Details form 
    # =========================================================================
    @http.route('/booking/details', type='http', auth='public', website=True)
    def booking_details_form(self, token, time_str, **kw):
        link_obj = request.env['meeting.booking.link'].sudo().search([('token', '=', token)], limit=1)
        if not link_obj: return "Token Invalid"
        
        host_user = link_obj.user_id
        
        try:
            # Display logic only
            dt_naive = datetime.strptime(time_str.strip(), '%Y-%m-%d %H:%M:%S')
            host_tz_name = host_user.tz or 'UTC'
            pretty_time_str = f"{dt_naive.strftime('%A, %d %b %Y - %H:%M')} ({host_tz_name})"
            
            return request.render('meeting_rooms.portal_booking_form_template', {
                'host': host_user,
                'token': token,
                'time_str': time_str, 
                'display_time': pretty_time_str,
                'default_name': request.env.user.name if not request.env.user._is_public() else '',
                'default_email': request.env.user.email if not request.env.user._is_public() else '',
            })
        except Exception as e:
            return f"Error: {str(e)}"

    # =========================================================================
    # 3. Submit booking (DEBUGGING LOGIC)
    # =========================================================================
    @http.route('/booking/submit', type='http', auth='public', website=True, csrf=True)
    def booking_submit(self, token, time_str, **kw):
        _logger.info(f"\n\n=== [DEBUG START] SUBMITTING BOOKING ===")
        _logger.info(f"RECEIVED TIME STRING: {time_str}")

        link_obj = request.env['meeting.booking.link'].sudo().search([
            ('token', '=', token),
            ('active', '=', True)
        ], limit=1)
        
        if not link_obj: return "Link Not Found"

        host_user = link_obj.user_id
        _logger.info(f"HOST: {host_user.name} | TZ: {host_user.tz}")

        if not host_user.tz:
            return "Host Timezone missing."

        # === DIAGNOSA TIMEZONE ===
        try:
            # 1. Parse string yang dikirim (Ini diasumsikan WAKTU LOKAL HOST)
            # Contoh: "2026-02-06 09:00:00"
            local_naive = datetime.strptime(time_str.strip(), '%Y-%m-%d %H:%M:%S')
            _logger.info(f"STEP 1 - PARSED RAW: {local_naive}")
            
            # 2. Tempelkan Timezone Host
            host_tz = pytz.timezone(host_user.tz)
            local_aware = host_tz.localize(local_naive)
            _logger.info(f"STEP 2 - HOST AWARE: {local_aware}")
            
            # 3. Konversi ke UTC (Ini yang harus masuk DB)
            utc_aware = local_aware.astimezone(pytz.utc)
            _logger.info(f"STEP 3 - CONVERTED TO UTC: {utc_aware}")
            
            # 4. Bersihkan info timezone agar Odoo mau terima (Naive UTC)
            start_dt_db = utc_aware.replace(tzinfo=None)
            end_dt_db = start_dt_db + timedelta(hours=1)
            _logger.info(f"STEP 4 - FINAL DB VALUE (NAIVE UTC): {start_dt_db}")
            
        except ValueError as e:
            _logger.error(f"TIME PARSING ERROR: {e}")
            return f"Invalid time format: {e}"

        # Validasi Email dll
        name = kw.get('name', 'Guest')
        email_input = (kw.get('email') or '').strip()
        email_list = [e.strip() for e in re.split(r'[;\n,]+', email_input) if e.strip()]
        if not email_list: return "Email required"

        final_subject = kw.get('subject') or f"Meeting with {name}"

        # Create/Find Partner
        Partner = request.env['res.partner'].sudo()
        guest_partner = Partner.search([('email', '=', email_list[0])], limit=1)
        if not guest_partner:
            guest_partner = Partner.create({'name': name, 'email': email_list[0], 'type': 'contact'})

        # Check Conflict
        domain = [
            ('start_date', '<', end_dt_db),
            ('end_date', '>', start_dt_db),
            ('attendee', 'in', [host_user.id]),
            ('state', '=', 'confirm')
        ]
        if request.env['meeting.event'].sudo().search_count(domain) > 0:
             _logger.warning("CONFLICT DETECTED")
             return "Slot already booked."

        # === CREATE EVENT ===
        _logger.info("CREATING RECORD IN ODOO...")
        # Penting: with_context(tz='UTC') agar Odoo tidak menggeser jam lagi
        new_event = request.env['meeting.event'].sudo().with_context(tz='UTC').create({
            'subject': final_subject,
            'start_date': start_dt_db, 
            'end_date': end_dt_db,     
            'attendee': [(4, host_user.id)],
            'state': 'draft',
            'host_user_id': host_user.id,
            'guest_partner_id': guest_partner.id,
            'guest_emails': ", ".join(email_list),
        })
        _logger.info(f"RECORD CREATED ID: {new_event.id}")
        _logger.info("=== [DEBUG END] SUBMIT COMPLETE ===\n")

        # Success Page
        display_time = local_naive.strftime('%A, %d %b %H:%M') + f" ({host_user.tz})"

        return f"""
            <div style='display:flex; justify-content:center; align-items:center; height:100vh; background-color:#f3f4f6; font-family:sans-serif;'>
                <div style='text-align:center; padding:40px; background:white; border-radius:10px; box-shadow:0 4px 15px rgba(0,0,0,0.1); max-width:550px;'>
                    <div style='color:#00A09D; font-size:60px; margin-bottom:20px;'>âœ”</div>
                    <h1 style='color:#2c3e50; margin-bottom:15px;'>Booking Confirmed!</h1>
                    <p style='color:#555;'>Meeting: <b>{display_time}</b></p>
                    <a href='/book/{token}' style='display:inline-block; padding:12px 25px; background-color:#00A09D; color:white; text-decoration:none; border-radius:5px;'>Close</a>
                </div>
            </div>
        """

=== FILE: ./controllers/__init__.py ===
from . import website
from . import booking_portal

=== FILE: ./security/meeting_security.xml ===
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="0">
        
        <record model="ir.module.category" id="module_category_meeting">
            <field name="name">Meeting System</field>
            <field name="description">Manage Meeting Rooms and Events</field>
            <field name="sequence">10</field>
        </record>

        <record id="group_meeting_user" model="res.groups">
            <field name="name">User</field>
            <field name="category_id" ref="module_category_meeting"/>
            <field name="implied_ids" eval="[(4, ref('base.group_user'))]"/>
        </record>

        <record id="group_meeting_manager" model="res.groups">
            <field name="name">Administrator</field>
            <field name="category_id" ref="module_category_meeting"/>
            <field name="implied_ids" eval="[(4, ref('meeting_rooms.group_meeting_user'))]"/>
            <field name="users" eval="[(4, ref('base.user_root')), (4, ref('base.user_admin'))]"/> 
        </record>

        <record id="rule_meeting_booking_link_read_all" model="ir.rule">
            <field name="name">Booking Link: Read All</field>
            <field name="model_id" ref="model_meeting_booking_link"/>
            <field name="domain_force">[(1, '=', 1)]</field> 
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/> <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="rule_meeting_booking_link_write_own" model="ir.rule">
            <field name="name">Booking Link: Edit Own Only</field>
            <field name="model_id" ref="model_meeting_booking_link"/>
            <field name="domain_force">[('user_id', '=', user.id)]</field> 
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/> <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="rule_meeting_booking_link_admin" model="ir.rule">
            <field name="name">Admin Edit All Booking Links</field>
            <field name="model_id" ref="model_meeting_booking_link"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('meeting_rooms.group_meeting_manager'))]"/> 
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="rule_meeting_event_read_all" model="ir.rule">
            <field name="name">Meeting Event: Read All</field>
            <field name="model_id" ref="model_meeting_event"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="rule_meeting_event_write_all_internal" model="ir.rule">
            <field name="name">Meeting Event: Write All (Internal)</field>
            <field name="model_id" ref="model_meeting_event"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="rule_meeting_event_own" model="ir.rule">
            <field name="name">Meeting Event: Manage Own</field>
            <field name="model_id" ref="model_meeting_event"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="rule_meeting_event_admin" model="ir.rule">
            <field name="name">Meeting Event: Admin Full</field>
            <field name="model_id" ref="model_meeting_event"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('meeting_rooms.group_meeting_manager'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="rule_meeting_rooms_read_all" model="ir.rule">
            <field name="name">Meeting Rooms: Read All</field>
            <field name="model_id" ref="model_meeting_rooms"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="False"/>
            <field name="perm_create" eval="False"/>
            <field name="perm_unlink" eval="False"/>
        </record>

        <record id="rule_meeting_rooms_own" model="ir.rule">
            <field name="name">Meeting Rooms: Manage Own</field>
            <field name="model_id" ref="model_meeting_rooms"/>
            <field name="domain_force">[('create_uid', '=', user.id)]</field>
            <field name="groups" eval="[(4, ref('base.group_user'))]"/>
            <field name="perm_read" eval="False"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

        <record id="rule_meeting_rooms_admin" model="ir.rule">
            <field name="name">Meeting Rooms: Admin Full</field>
            <field name="model_id" ref="model_meeting_rooms"/>
            <field name="domain_force">[(1, '=', 1)]</field>
            <field name="groups" eval="[(4, ref('meeting_rooms.group_meeting_manager'))]"/>
            <field name="perm_read" eval="True"/>
            <field name="perm_write" eval="True"/>
            <field name="perm_create" eval="True"/>
            <field name="perm_unlink" eval="True"/>
        </record>

    </data>
</odoo>

=== FILE: ./security/ir.model.access.csv ===
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_meeting_rooms,access_meeting_rooms,model_meeting_rooms,base.group_user,1,1,1,1
access_room_location,access_room_location,model_room_location,base.group_user,1,1,1,1
access_meeting_event,access_meeting_event,model_meeting_event,base.group_user,1,1,1,1
access_virtual_room_user,virtual.room user,model_virtual_room,base.group_user,1,1,1,0
access_meeting_booking_link_user,meeting.booking.link.user,model_meeting_booking_link,base.group_user,1,1,0,1
access_meeting_booking_link_portal,meeting.booking.link.portal,model_meeting_booking_link,base.group_portal,1,0,0,0
access_meeting_booking_link_manager,meeting.booking.link.manager,model_meeting_booking_link,base.group_system,1,1,1,1
access_meeting_rooms_mgr,meeting_rooms_mgr,model_meeting_rooms,meeting_rooms.group_meeting_manager,1,1,1,1
access_room_location_mgr,room_location_mgr,model_room_location,meeting_rooms.group_meeting_manager,1,1,1,1
access_meeting_event_mgr,meeting_event_mgr,model_meeting_event,meeting_rooms.group_meeting_manager,1,1,1,1
access_virtual_room_mgr,virtual_room_mgr,model_virtual_room,meeting_rooms.group_meeting_manager,1,1,1,1
access_meeting_booking_link_mgr_new,booking_link_mgr_new,model_meeting_booking_link,meeting_rooms.group_meeting_manager,1,1,1,1

=== FILE: ./models/__init__.py ===
from . import model
from . import meeting_event
from . import meeting_rooms_ext
from . import virtual_room
from . import booking_link

=== FILE: ./models/model.py ===
from odoo import fields, models, api, _
from datetime import datetime, timedelta, date
from odoo.exceptions import AccessDenied, UserError, ValidationError
import pytz
import subprocess
import base64

# put POSIX 'Etc/*' entries at the end to avoid confusing users - see bug 1086728
_tzs = [(tz, tz) for tz in sorted(pytz.all_timezones, key=lambda tz: tz if not tz.startswith('Etc/') else '_')]
def _tz_get(self):
    return _tzs

class MeetingRoomsLocation(models.Model):
    _name = 'room.location'
    _description = 'Meeting Room Location'

    name = fields.Char("Location")
    active = fields.Boolean("active ?", default=True)
    location_address = fields.Text("Address")
    location_description = fields.Text("Description")
    tz = fields.Selection(_tz_get, string='Timezone', default=lambda self: self._context.get('tz'),
                          help="When printing documents and exporting/importing data, time values are computed according to this timezone.\n"
                               "If the timezone is not set, UTC (Coordinated Universal Time) is used.\n"
                               "Anywhere else, time values are computed according to the time offset of your web client.")
    tz_offset = fields.Char("Offset", compute = '_compute_offset')

    def _compute_offset(self):
        for record in self:
            timezone = record.tz or 'UTC'  # Default to UTC if no timezone is set

            time_zone = pytz.timezone(timezone)
            current_time = datetime.now(pytz.utc).astimezone(time_zone)

            timezone_offset = current_time.utcoffset().total_seconds() / 60

            offset_hours = int(timezone_offset // 60)
            offset_minutes = int(abs(timezone_offset) % 60)

            # Format the offset (e.g., +08:00, -05:30, etc.)
            record.tz_offset = f"{'+' if offset_hours >= 0 else '-'}{abs(offset_hours):02d}{abs(offset_minutes):02d}"


class MeetingRooms(models.Model):
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _name = 'meeting.rooms'
    _description = 'Meeting Rooms Booking'

    name = fields.Char("Name")
    subject = fields.Char("Subject")
    room_location = fields.Many2one("room.location", string="Location", required=True)
    start_date = fields.Datetime("Start", required=True)
    end_date = fields.Datetime("End", required=True)
    attendee = fields.Many2many("res.users", string="Attendee")
    description = fields.Text("Description")
    calendar_alarm = fields.Many2one("calendar.alarm", string="Reminder", required=True)
    state = fields.Selection([('draft', 'Draft'),
                              ('confirm', 'Confirm'),('cancel','Cancelled')], string='Status',tracking=True, copy=False,default='confirm')
    recurrency = fields.Boolean('Recurrent', help="Recurrent Meeting")
    rrule_type = fields.Selection([
        ('daily', 'Daily'),
        ('weekly', 'Weekly')
    ], string='Recurrence', help="Let the event automatically repeat at that interval")
    final_date = fields.Date('Repeat Until')
    action = fields.Boolean("Action")
    email_sent = fields.Boolean("Email Sent?")
    version = fields.Integer("Version", default=1)
    calendar_file = fields.Binary(string="Calendar File")
    
    virtual_room_id = fields.Many2one('virtual.room', string="Virtual Room")

    # =========================================================================
    # Security functions (access control)
    # =========================================================================
    def _check_readonly_access(self):
        """
        Check if user has permission to create/edit/delete meeting rooms.
        Meeting rooms are auto-created from meeting.event, so direct edit is blocked.
        Internal system operations can bypass this check using 'skip_readonly_check' context.
        """
        if self.env.context.get('skip_readonly_check'):
            return True
            
        # English error message
        raise UserError(_(
            "ACCESS DENIED!\n\n"
            "You cannot create, edit, or delete Bookings manually here.\n"
            "Please go to 'Meeting Events' menu to manage schedules."
        ))

    def _get_display_tz_name(self):
        self.ensure_one()
        event = getattr(self, 'meeting_event_id', False)
        if event and event.host_user_id and event.host_user_id.tz:
            return event.host_user_id.tz
        if self.create_uid and self.create_uid.tz:
            return self.create_uid.tz
        return 'UTC'

    def _convert_utc_to_tz(self, dt, tz_name):
        if not dt:
            return dt
        tz = pytz.timezone(tz_name or 'UTC')
        if dt.tzinfo is None:
            dt = pytz.utc.localize(dt)
        return dt.astimezone(tz)

    def _tz_offset_str(self, tz_name, ref_dt=None):
        if not ref_dt:
            ref_dt = fields.Datetime.now()
        local_dt = self._convert_utc_to_tz(ref_dt, tz_name)
        utc_offset = local_dt.utcoffset() or timedelta(0)
        offset_total_seconds = utc_offset.total_seconds()
        offset_hours = int(offset_total_seconds // 3600)
        offset_minutes = int(abs(offset_total_seconds) % 3600 // 60)
        return f"{'+' if offset_hours >= 0 else '-'}{abs(offset_hours):02d}{abs(offset_minutes):02d}"

    def send_email_meeting(self):
        self.ensure_one()
        event = getattr(self, 'meeting_event_id', False)
        if event:
            return event.create_calendar_web()
        for rec in self :
            tz_name = rec._get_display_tz_name()
            start_time = rec._convert_utc_to_tz(rec.start_date, tz_name)
            end_time = rec._convert_utc_to_tz(rec.end_date, tz_name)
            create_time = rec._convert_utc_to_tz(rec.create_date, tz_name)
            write_time = rec._convert_utc_to_tz(rec.write_date, tz_name)
            tz_offset_str = rec._tz_offset_str(tz_name, rec.start_date)
            reminder = int(rec.calendar_alarm.duration) if rec.calendar_alarm.duration else 1
            attendee_str = ''
            for user in rec.attendee :
                attendee_str += f'ATTENDEE;ROLE=REQ-PARTICIPANT;RSVP=TRUE;CN="{user.display_name}":mailto:{user.email}'
                if user != rec.attendee[-1]:
                    attendee_str += '\n'
            icsContent = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//ZContent.net//Zap Calendar 1.0//EN
CALSCALE:GREGORIAN
METHOD:REQUEST

BEGIN:VTIMEZONE
TZID:{tz_name}
X-LIC-LOCATION:${tz_name}
BEGIN:STANDARD
DTSTART:19700101T000000
TZOFFSETFROM:{tz_offset_str}
TZOFFSETTO:{tz_offset_str}
TZNAME:${tz_name}
END:STANDARD
END:VTIMEZONE

BEGIN:VEVENT
UID:{rec.id}
SEQUENCE:{rec.version}
SUMMARY:{rec.subject}
DTSTAMP:{create_time}
LAST-MODIFIED:{write_time}
DTSTART;TZID={tz_name}:{start_time}
DTEND;TZID={tz_name}:{end_time}
LOCATION:{rec.room_location.name}
DESCRIPTION:{rec.description}
ORGANIZER;PARTSTAT=ACCEPTED;CN="{rec.create_uid.display_name}":mailto:{rec.create_uid.email}
{attendee_str}
BEGIN:VALARM
TRIGGER:-PT${reminder}M
ACTION:DISPLAY
DESCRIPTION:Reminder
END:VALARM
END:VEVENT
END:VCALENDAR`;
            """
            filename = f"{rec.subject}.ics"
            with open(filename, 'w') as file:
                file.write(icsContent)

            with open(filename, 'rb') as file:
                attachment_calendar = self.env['ir.attachment'].sudo().search(
                    [('res_model', '=', 'meeting.rooms'), ('type', '=', 'binary'), ('res_field', '=', 'calendar_file'),('res_id', '=', rec.id)])
                if attachment_calendar:
                    attachment_calendar.unlink()
                    attachment = self.env['ir.attachment'].sudo().create({
                        'name': filename,
                        'type': 'binary',
                        'res_model': 'meeting.rooms',
                        'res_field': 'calendar_file',
                        'res_id': rec.id,
                        'res_name': filename,
                        'datas': base64.b64encode(file.read()),
                        'public': True
                    })
                else:
                    attachment = self.env['ir.attachment'].sudo().create({
                        'name': filename,
                        'type': 'binary',
                        'res_model': 'meeting.rooms',
                        'res_field': 'calendar_file',
                        'res_id': rec.id,
                        'res_name': filename,
                        'datas': base64.b64encode(file.read()),
                        'public': True
                    })



    def create_calendar_event(self):
        for rec in self :
            tz_name = rec._get_display_tz_name()
            start_time = rec._convert_utc_to_tz(rec.start_date, tz_name)
            end_time = rec._convert_utc_to_tz(rec.end_date, tz_name)
            start_day = start_time.day
            start_month = start_time.month
            start_year = start_time.year
            start_hour = start_time.hour
            start_minute = start_time.minute
            start_second = start_time.second
            end_day = end_time.day
            end_month = end_time.month
            end_year = end_time.year
            end_hour = end_time.hour
            end_minute = end_time.minute
            end_second = end_time.second
            subject = rec.subject
            reminder = int(rec.calendar_alarm.duration) if rec.calendar_alarm.duration else 1
            description = rec.description if rec.description else None

            attendee = ''
            for user in self.attendee :
                if user.display_name and user.email :
                    attendee += 'make new attendee at beginning of attendees with properties {display name:"%s", email:"%s"}\n' %(user.display_name,user.email)

            applescript = """
        set theStartDate to (current date) 
        set year of theStartDate to %s
        set month of theStartDate to %s
        set day of theStartDate to %s
        set hours of theStartDate to %s
        set minutes of theStartDate to %s
        set seconds of theStartDate to %s
        set theEndDate to (current date) 
        set year of theEndDate to %s
        set month of theEndDate to %s
        set day of theEndDate to %s
        set hours of theEndDate to %s
        set minutes of theEndDate to %s
        set seconds of theEndDate to %s
        
        tell application "Calendar"
        activate
            tell calendar "Home"
                set new_event to make new event at end of events with properties {summary:"%s", start date:theStartDate, end date:theEndDate, location:"%s", description:"%s"}
            end tell
            tell new_event
                %s
            end tell
            tell new_event
                make new sound alarm at end of sound alarms with properties {trigger interval:-%s, sound name:"Sosumi"}
            end tell
        end tell
            """ % (start_year, start_month, start_day, start_hour, start_minute, start_second, end_year, end_month, end_day,
                   end_hour, end_minute, end_second, subject,rec.room_location.name,description,attendee,reminder)

            subprocess.run(['osascript', '-e', applescript])


    def run_calendar(self):
        for rec in self :
            self.create_calendar_event()

    def create_calendar_web(self):
        self.ensure_one()
        event = getattr(self, 'meeting_event_id', False)
        if event:
            return event.create_calendar_web()
        return {
            'name': "Create Calendar",
            'type': 'ir.actions.act_url',
            'url': f"/create-icalendar?id={self.id}",
            'target': 'new',
        }

    def action_confirm(self):
        for rec in self:
            rec.state = 'confirm'
            # Activity notifications centralized in meeting.event model

    def action_cancel(self):
        """Cancel meeting room booking with security check."""
        # === SECURITY CHECK FIRST ===
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        for rec in self:
            if rec.create_uid != self.env.user and not is_manager:
                raise UserError(_(
                    f"ACCESS DENIED!\n\n"
                    f"You cannot cancel this booking.\n"
                    f"Only the creator ({rec.create_uid.name}) or a Meeting Administrator can cancel bookings."
                ))
        # ================================
        
        for rec in self :
            tz_name = rec._get_display_tz_name()
            start_time = rec._convert_utc_to_tz(rec.start_date, tz_name)
            end_time = rec._convert_utc_to_tz(rec.end_date, tz_name)
            rec.activity_feedback(['meeting_rooms.mail_act_meeting_rooms_approval'])
            group = []
            for user in rec.attendee :
                group.append(user.partner_id.id)
            value = {'partner_ids': group,
                     'channel_ids': [],
                     'body': f"Meeting {rec.subject} from {start_time} to {end_time} in {rec.room_location.name} Is Cancelled",
                     'attachment_ids': [],
                     'canned_response_ids': [],
                     'message_type': 'comment',
                     'subtype': 'mail.mt_note'}
            rec.message_post(**value)
            rec.state = 'cancel'

    def action_draft(self):
        self.state = 'draft'

    def unlink(self):
        self._check_readonly_access()
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        if self.create_uid != self.env.user and not is_manager:
            raise UserError(_(f"Only the creator ({self.create_uid.name}) or a Meeting Administrator can delete this record."))
        return super(MeetingRooms, self).unlink()

    @api.constrains('start_date', 'end_date', 'room_location')
    def _check_booking_validity(self):
        """
        Validate meeting room availability to prevent double bookings.
        Checks for time overlaps within the same room location.
        Optimized: Uses domain-based search instead of O(nÂ²) loop.
        """
        if self.env.context.get('skip_double_booking_check'):
            return

        for record in self:
            # Validate end_date > start_date
            if record.end_date <= record.start_date:
                raise ValidationError(_("End date cannot be before or equal to start date."))
            
            # OPTIMIZED: Only search for conflicting bookings in same room
            # (not ALL records like before)
            domain = [
                ('id', '!=', record.id),  # Exclude self
                ('room_location', '=', record.room_location.id),  # Same room ONLY
                ('start_date', '<', record.end_date),  # Time overlap check
                ('end_date', '>', record.start_date),
                ('state', '=', 'confirm'),  # Only confirmed bookings
            ]
            
            conflicts = self.search(domain)  # Get only relevant records (not ALL!)
            
            if conflicts:
                # Get first conflict for error message
                conflict = conflicts[0]
                tz_name = record._get_display_tz_name()
                start_time = record._convert_utc_to_tz(conflict.start_date, tz_name)
                end_time = record._convert_utc_to_tz(conflict.end_date, tz_name)
                
                raise ValidationError(
                    _(f"Room conflict: '{record.room_location.name}' is already booked "
                      f"from {start_time.strftime('%Y-%m-%d %H:%M')} to {end_time.strftime('%Y-%m-%d %H:%M')}. "
                      f"Please choose another time slot.")
                )

    @api.model
    def create(self, vals):
        self._check_readonly_access()

        vals['name'] = vals['subject']
        values = super(MeetingRooms, self).create(vals)
        # Activity notifications are centralized in meeting.event model
        # to prevent duplicate notifications (one from meeting.event, one from meeting.rooms).

        if not self.env.context.get('skip_double_booking_check'):
            tz_name = values._get_display_tz_name()
            start_time = values._convert_utc_to_tz(values.start_date, tz_name)
            end_time = values._convert_utc_to_tz(values.end_date, tz_name)
            formatted_start_time = start_time.strftime('%b %d, %Y')
            start_time_hours = start_time.strftime('%H:%M')
            formatted_end_time = end_time.strftime('%b %d, %Y %H:%M')
            end_time_hours = end_time.strftime('%H:%M')
            duration = end_time - start_time
            meeting_hours, remainder = divmod(duration.total_seconds(), 3600)
            meeting_minutes, meeting_seconds = divmod(remainder, 60)
            meeting_hours_str = ""
            if meeting_hours > 0:
                meeting_hours_str = f"{int(meeting_hours)} hours "

            meeting_minutes_str = ""
            if meeting_minutes > 0:
                meeting_minutes_str = f"{int(meeting_minutes)} minutes"

        if values.recurrency :
            if values.rrule_type == "daily" :
                delta = timedelta(days=1)
                start_date = values.start_date
                end_date = values.end_date
                date_count = values.start_date.date()
                while date_count <= values.final_date :
                    start_date += delta
                    end_date += delta
                    date_count += delta
                    value = {
                        'subject' : values.subject,
                        'name' : values.name,
                        'start_date' : start_date,
                        'end_date' : end_date,
                        'description' : values.description,
                        'calendar_alarm' : values.calendar_alarm.id,
                        'attendee' : values.attendee,
                        'room_location' : values.room_location.id
                    }
                    meeting = self.env['meeting.rooms'].sudo().with_context(skip_readonly_check=True).create(value)

            elif values.rrule_type == "weekly":
                delta = timedelta(days=7)
                start_date = values.start_date
                end_date = values.end_date
                date_count = values.start_date.date()
                while date_count <= values.final_date:
                    start_date += delta
                    end_date += delta
                    date_count += delta
                    value = {
                        'subject': values.subject,
                        'name': values.name,
                        'start_date': start_date,
                        'end_date': end_date,
                        'description': values.description,
                        'calendar_alarm': values.calendar_alarm.id,
                        'attendee': values.attendee,
                        'room_location': values.room_location.id
                    }
                    meeting = self.env['meeting.rooms'].sudo().with_context(skip_readonly_check=True).create(value)
        return values

    def write(self, vals):
        """Override write to enforce readonly access control."""
        self._check_readonly_access()
        if self.env.context.get('force_sync'):
            return super(MeetingRooms, self).write(vals)

        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')

        if self.create_uid != self.env.user and not is_manager:
            raise UserError(_(f"Only the creator ({self.create_uid.name}) or a Meeting Administrator can edit this record."))
        else:
            return super(MeetingRooms, self).write(vals)

=== FILE: ./models/meeting_event.py ===
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError, UserError
from datetime import datetime, timedelta
import pytz
import base64
import logging
import requests
import re
from requests.auth import HTTPBasicAuth
import urllib.parse
import json
import time

_logger = logging.getLogger(__name__)

# Helper for timezone
_tzs = [(tz, tz) for tz in sorted(pytz.all_timezones, key=lambda tz: tz if not tz.startswith('Etc/') else '_')]
def _tz_get(self):
    return _tzs

class MeetingEvent(models.Model):
    _name = 'meeting.event'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _description = 'Meeting Event (Master)'
    _rec_name = 'subject'

    # ==========================================================
    # FIELDS DEFINITION
    # ==========================================================
    @api.model
    def create(self, vals):
        """
        Create a new meeting event with validation and auto-add creator as attendee.
        
        Args:
            vals: Dictionary of field values for the new record
            
        Returns:
            New meeting.event record
            
        Raises:
            ValidationError: If end_date <= start_date
        """
        # POIN 6: Validate date range before creation
        if vals.get('start_date') and vals.get('end_date'):
            start_date = fields.Datetime.to_datetime(vals['start_date'])
            end_date = fields.Datetime.to_datetime(vals['end_date'])
            if end_date <= start_date:
                raise ValidationError(_("End date must be after start date."))
        
        res = super(MeetingEvent, self).create(vals)
        if res.create_uid.id not in res.attendee.ids:
            # Add creator as attendee WITHOUT context to avoid timezone conversion
            res.write({
                'attendee': [(4, res.create_uid.id)] 
            })
        return res

    # =========================
    # =========================
    # MAIN FIELDS
    # =========================
    subject = fields.Char("Subject", required=True, tracking=True)
    room_location_ids = fields.Many2many('room.location', string="Locations")
    virtual_room_id = fields.Many2one('virtual.room', string="Virtual Room Provider")

    start_date = fields.Datetime("Start", required=True)
    end_date = fields.Datetime("End", required=True)
    attendee = fields.Many2many("res.users", string="Attendee")
    description = fields.Text("Description")
    calendar_alarm = fields.Many2one("calendar.alarm", string="Reminder")

    # === NEW FIELD: TO USER EKSTERNAL ===
    guest_partner_id = fields.Many2one(
        'res.partner', 
        string="External Guest", 
        help="Guest data from booking portal"
    )
    host_user_id = fields.Many2one(
        'res.users',
        string="Host User",
        default=lambda self: self.env.user,
        help="Primary host for timezone and ownership context"
    )
    guest_emails = fields.Char(
        string="Guest Emails",
        help="Additional guest emails (comma-separated) from booking portal"
    )
    # ========================================

    zoom_id = fields.Char(string="Meeting ID", readonly=True, copy=False) 
    zoom_link = fields.Char(string="Join URL", readonly=True, copy=False)
    zoom_invitation = fields.Text(string="Invitation Text", copy=False)
    zoom_start_url = fields.Char(string='Start URL', readonly=True, copy=False)
    ai_summary = fields.Html(string='AI Summary Result', sanitize=False, copy=False)

    recurrency = fields.Boolean('Recurrent', help="Recurrent Meeting")
    rrule_type = fields.Selection([
        ('daily', 'Daily'),
        ('weekly', 'Weekly')
    ], string='Recurrence', help="Let the event automatically repeat at that interval")
    final_date = fields.Date('Repeat Until')

    version = fields.Integer("Version", default=1)
    calendar_file = fields.Binary(string="Calendar File")

    state = fields.Selection(
        [('draft', 'Draft'), ('confirm', 'Confirm'), ('cancel', 'Cancelled')],
        string='Status', default='draft', tracking=True
    )

    meeting_room_ids = fields.One2many(
        'meeting.rooms', 
        'meeting_event_id', 
        string="Booked Rooms List",
        readonly=True 
    )

    # ==========================================================
    # Helper: Compute local times (eliminate code duplication)
    # ==========================================================
    def _compute_local_times(self, tz_name=None):
        """
        Convert meeting times to local timezone with proper DST handling.
        
        This method consolidates timezone conversion logic used in multiple places.
        Properly handles DST by converting the meeting datetime itself, not using current offset.
        
        Args:
            tz_name: Timezone name (if None, uses creator timezone)
        
        Returns:
            dict with keys: 'tz', 'tz_name', 'local_start', 'local_end', 
                           'formatted_date', 'start_time_hours', 'end_time_hours',
                           'tz_offset_str'
        """
        self.ensure_one()
        
        if not tz_name:
            tz_name = (self.host_user_id.tz or self.create_uid.tz or 'UTC')
        
        tz = pytz.timezone(tz_name)
        
        # âœ… CORRECT: Convert the MEETING datetime to its timezone (handles DST correctly)
        start_dt = self.start_date
        end_dt = self.end_date
        if start_dt and start_dt.tzinfo is None:
            start_dt = pytz.utc.localize(start_dt)
        if end_dt and end_dt.tzinfo is None:
            end_dt = pytz.utc.localize(end_dt)

        local_start = start_dt.astimezone(tz)
        local_end = end_dt.astimezone(tz)
        
        # Format strings
        formatted_date = local_start.strftime('%b %d, %Y')
        start_time_hours = local_start.strftime('%H:%M')
        end_time_hours = local_end.strftime('%H:%M')
        
        # Timezone offset string for ICS
        utc_offset = local_start.utcoffset()
        offset_total_seconds = utc_offset.total_seconds()
        offset_hours = int(offset_total_seconds // 3600)
        offset_minutes = int(abs(offset_total_seconds) % 3600 // 60)
        tz_offset_str = f"{'+' if offset_hours >= 0 else '-'}{abs(offset_hours):02d}{abs(offset_minutes):02d}"
        
        return {
            'tz': tz,
            'tz_name': tz_name,
            'local_start': local_start,
            'local_end': local_end,
            'formatted_date': formatted_date,
            'start_time_hours': start_time_hours,
            'end_time_hours': end_time_hours,
            'tz_offset_str': tz_offset_str,
        }

    # ==========================================================
    # LOGIC: REGENERATE ACTIVITY
    # ==========================================================
    def _regenerate_all_activities(self):
        """
        Regenerate activity notifications for all meeting attendees.
        
        This method:
        1. Deletes all existing activities for this meeting
        2. Creates new activities for each attendee with formatted meeting details
        3. Uses creator's timezone for display consistency
        
        Context:
            mail_activity_automation_skip: If True, skip activity generation
        """
        self.ensure_one()
        ev = self

        if self.env.context.get('mail_activity_automation_skip'):
            return

        # 1. WIPE OLD ACTIVITIES
        old_activities = self.env['mail.activity'].search([
            ('res_id', '=', ev.id),
            ('res_model', '=', 'meeting.event')
        ])
        old_activities.unlink()

        # 2. Use helper for timezone conversion (fix POIN 4 - code duplication)
        local_times = ev._compute_local_times()
        
        loc_name = ", ".join(ev.room_location_ids.mapped('name')) if ev.room_location_ids else "Virtual"
        formatted_start_time = local_times['formatted_date']
        start_time_hours = local_times['start_time_hours']
        end_time_hours = local_times['end_time_hours']
        tz_name = local_times['tz_name']
        
        duration = local_times['local_end'] - local_times['local_start']
        meeting_hours, remainder = divmod(duration.total_seconds(), 3600)
        meeting_minutes, meeting_seconds = divmod(remainder, 60)
        meeting_hours_str = f"{int(meeting_hours)} hours " if meeting_hours > 0 else ""
        meeting_minutes_str = f"{int(meeting_minutes)} minutes" if meeting_minutes > 0 else ""

        virtual_room_info = ""
        if ev.zoom_link:
                virtual_room_info = f"<br/><br/><b>Online Meeting:</b> <a href='{ev.zoom_link}' target='_blank'>Click to Join</a>"
        elif ev.virtual_room_id:
            virtual_room_info = f"<br/>(Virtual Room: {ev.virtual_room_id.name})"

        # 3. REGENERATE
        for user in ev.attendee:
              ev.sudo().activity_schedule(
                'meeting_rooms.mail_act_meeting_rooms_approval',
                user_id=user.id,
                date_deadline=local_times['local_start'].date(),
                note=f"""
                    Hi <b>{user.name}</b>,<br/><br/>
                    I hope this message finds you well. <b>{ev.create_uid.name}</b> has invited you to the "{ev.subject}" meeting<br/><br/>
                    <table border="0">
                        <tbody>
                            <tr>
                                <td style="width:80px;">Date</td>
                                <td>: {formatted_start_time}</td>
                            </tr>
                            <tr>
                                <td>Time</td>
                                <td>: {start_time_hours} - {end_time_hours} ({tz_name})</td>
                            </tr>
                             <tr>
                                <td>Time (UTC)</td>
                                <td>: {ev.start_date} - {ev.end_date}</td>
                            </tr>
                            <tr>
                                <td>Duration</td>
                                <td>: {meeting_hours_str}{meeting_minutes_str}</td>
                            </tr>
                            <tr>
                                <td>Location</td>
                                <td>: {loc_name} {virtual_room_info}</td>
                            </tr>
                        </tbody>
                    </table>
                    <br/>
                """
            )

    def _can_shared_action(self):
        """Allow internal users to run limited actions without edit rights."""
        self.ensure_one()
        if self.env.user.has_group('meeting_rooms.group_meeting_manager'):
            return True
        if self.env.user.has_group('base.group_user'):
            return True
        return False

    # ==========================
    # OVERRIDE UNLINK (PERMANENT DELETE)
    # ==========================
    def unlink(self):
        """
        Ensure that when user deletes an Event from database,
        the corresponding Zoom meeting is also deleted from Zoom server.
        """
        # === SECURITY PRE-CHECK ===
        # Manually check if user has permission to delete.
        # If not, raise error BEFORE touching Zoom API.
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        for rec in self:
            if rec.create_uid != self.env.user and not is_manager:
                raise UserError(_("Access Denied: You can only delete your own meetings."))
        # ==========================================

        # If security check passes, proceed with Zoom deletion
        for rec in self:
            if rec.zoom_id and rec.virtual_room_id and rec.virtual_room_id.provider == 'zoom':
                try:
                    # Pass the current virtual room to ensure credentials are found
                    rec._logic_delete_zoom_meeting(rec.zoom_id, context_room=rec.virtual_room_id)
                except Exception as e:
                    _logger.warning(f"Failed to delete Zoom on Unlink: {str(e)}")
        
        # Continue deleting record in Odoo (this will also invoke built-in Record Rules as double check)
        return super(MeetingEvent, self).unlink()

    # ==========================
    # Write / edit logic (transaction-safe)
    # ==========================
    def write(self, vals):
        """
        Update meeting event with transaction-safe Zoom meeting management.
        
        When rescheduling (changing dates/virtual room):
        1. Store old Zoom credentials for deletion
        2. Commit changes to database (may fail if conflict)
        3. If successful, delete old Zoom meeting using stored credentials
        4. Regenerate activities if meeting is confirmed
        
        Args:
            vals: Dictionary of field values to update
            
        Returns:
            Result of super().write()
        
        Context:
            skip_rooms_sync: Skip automatic meeting.rooms synchronization
        """
        vals = dict(vals)
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        is_owner = all(rec.create_uid == self.env.user for rec in self)
        use_sudo_write = False

        if not is_manager and not is_owner:
            if not self.env.user.has_group('base.group_user'):
                raise UserError(_("You are not allowed to edit this meeting."))

            # Drop unchanged protected fields commonly sent by the form.
            blocked_fields = {
                'start_date',
                'end_date',
                'state',
                'meeting_room_ids',
                'zoom_id',
                'zoom_link',
                'zoom_start_url',
                'zoom_invitation',
                'ai_summary',
                'create_uid',
                'create_date',
                'write_date',
                'host_user_id',
            }
            for field_name in list(blocked_fields):
                if field_name in vals:
                    new_val = vals[field_name]
                    if field_name in {'start_date', 'end_date'}:
                        new_val = fields.Datetime.to_datetime(new_val)
                        if any(fields.Datetime.to_datetime(getattr(rec, field_name)) != new_val for rec in self):
                            raise UserError(_(
                                "You can only update meeting details (location, attendees, and description). "
                                "Start/end time, cancel, and delete are restricted to host or administrator."
                            ))
                    vals.pop(field_name, None)

            allowed_fields = {
                'subject',
                'description',
                'room_location_ids',
                'virtual_room_id',
                'attendee',
                'calendar_alarm',
                'guest_partner_id',
                'guest_emails',
                'recurrency',
                'rrule_type',
                'final_date',
            }
            extra_fields = set(vals.keys()) - allowed_fields
            if extra_fields:
                raise UserError(_(
                    "You can only update meeting details (location, attendees, and description). "
                    "Start/end time, cancel, and delete are restricted to host or administrator."
                ))

            use_sudo_write = True

        reschedule_fields = ['start_date', 'end_date', 'virtual_room_id']
        is_rescheduling = any(f in vals for f in reschedule_fields)

        # 1. Prepare to delete (BUT WAIT)
        zoom_meetings_to_delete = {}
        work = self.sudo() if use_sudo_write else self
        
        if is_rescheduling:
            for rec in work:
                if rec.zoom_id and rec.virtual_room_id and rec.virtual_room_id.provider == 'zoom':
                    # Store ID and the Record Object of the Virtual Room
                    zoom_meetings_to_delete[rec.id] = {
                        'id': rec.zoom_id,
                        'room': rec.virtual_room_id
                    }
            
            # Reset fields in vals to clear UI
            vals['zoom_id'] = False
            vals['zoom_link'] = False
            vals['zoom_start_url'] = False
            vals['zoom_invitation'] = False
            vals['ai_summary'] = False 

        trigger_fields = ['room_location_ids', 'subject', 'attendee', 'zoom_link']
        is_update_needed = is_rescheduling or any(f in vals for f in trigger_fields)
        
        # 2. COMMIT TO DB (This might raise Validation Error if clash)
        res = super(MeetingEvent, work).write(vals)

        # 3. IF SUCCESS, DELETE ZOOM USING OLD CREDENTIALS
        if is_rescheduling:
            # Invalidate cache to ensure zoom fields are properly cleared
            work.invalidate_cache(['zoom_id', 'zoom_link', 'zoom_start_url', 'zoom_invitation', 'ai_summary'])
            
            for rec in work:
                old_data = zoom_meetings_to_delete.get(rec.id)
                if old_data:
                    # Pass the OLD room record to the delete logic
                    rec._logic_delete_zoom_meeting(old_data['id'], context_room=old_data['room'])
            
            for ev in work:
                if ev.state == 'confirm':
                    ev.message_post(body="<b>Schedule Changed.</b> Old meeting link has been deleted. Please click 'Generate Meeting Link' again.")

        # 4. Sync Rooms (Updates timestamps, freeing old slots)
        for ev in work:
            if not self.env.context.get('skip_rooms_sync'):
                ev._sync_rooms_from_event()

            if ev.state == 'confirm' and is_update_needed:
                ev._regenerate_all_activities()
                        
        return res

    # ==========================
    # ACTION CONFIRM
    # ==========================
    def action_confirm(self):
        """
        Confirm meeting event and trigger activities and room synchronization.
        
        This action:
        1. Regenerates activity notifications for all attendees
        2. Changes state to 'confirm'
        3. Synchronizes meeting.rooms records
        """
        for ev in self:
            _logger.info(
                "[CONFIRM] user_id=%s login=%s event_id=%s state=%s host_id=%s create_uid=%s",
                self.env.user.id,
                self.env.user.login,
                ev.id,
                ev.state,
                ev.host_user_id.id if ev.host_user_id else None,
                ev.create_uid.id if ev.create_uid else None,
            )
            if not ev._can_shared_action():
                _logger.warning(
                    "[CONFIRM DENIED] user_id=%s event_id=%s reason=no_shared_action",
                    self.env.user.id,
                    ev.id,
                )
                raise UserError(_("You are not allowed to confirm this meeting."))

            target = ev if (ev.create_uid == ev.env.user or ev.env.user.has_group('meeting_rooms.group_meeting_manager')) else ev.sudo()
            target._regenerate_all_activities()
            target.write({'state': 'confirm'})
            target.with_context(skip_booking_check=True)._sync_rooms_from_event()
            _logger.info("[CONFIRM OK] user_id=%s event_id=%s", self.env.user.id, ev.id)
        return True

    # ==========================================================
    # Virtual room actions & helpers
    # ==========================================================
    
    def _get_zoom_supported_timezone(self, tz_name=None):
        """
        Convert user timezone to Zoom-supported timezone.
        
        Zoom API doesn't support all pytz timezone names, so we map
        unsupported Indonesian timezones to their supported equivalents.
        
        Args:
            tz_name: Timezone name to convert (if None, uses creator timezone)
            
        Returns:
            Zoom-compatible timezone string
        """
        if not tz_name:
            tz_name = (self.host_user_id.tz or self.create_uid.tz or 'UTC')
        
        # Map unsupported Indonesian timezones to Zoom-supported ones
        mapping = {
            'Asia/Makassar': 'Asia/Singapore', 
            'Asia/Ujung_Pandang': 'Asia/Singapore', 
            'Asia/Jakarta': 'Asia/Bangkok', 
            'Asia/Pontianak': 'Asia/Bangkok', 
            'Asia/Jayapura': 'Asia/Tokyo',
        }
        return mapping.get(tz_name, tz_name)

    def _logic_delete_zoom_meeting(self, meeting_id, context_room=None):
        """
        Delete a Zoom meeting from Zoom server.
        
        Args:
            meeting_id: Zoom meeting ID (must be numeric string)
            context_room: virtual.room record with credentials (uses self.virtual_room_id if None)
        """
        try:
            if not meeting_id.isdigit(): 
                return 
            
            url = f"https://api.zoom.us/v2/meetings/{meeting_id}"
            headers = self._get_zoom_headers(context_room)
            
            res = requests.delete(url, headers=headers, timeout=10)
            if res.status_code == 204:
                _logger.info(f"Zoom Meeting {meeting_id} deleted successfully.")
                self.message_post(body=f"Previous Zoom Meeting ({meeting_id}) deleted from server.")
            else:
                _logger.warning(f"Failed to delete Zoom {meeting_id}: {res.text}")
        except Exception as e:
            _logger.error(f"Error deleting zoom: {e}")

    def action_generate_virtual_link(self):
        """
        Generate virtual meeting link based on selected provider (Zoom/Teams/Google Meet).
        
        Raises:
            UserError: If no virtual room is selected
        """
        self.ensure_one()
        if not self._can_shared_action():
            raise UserError(_("You are not allowed to generate meeting links."))

        target = self if (self.create_uid == self.env.user or self.env.user.has_group('meeting_rooms.group_meeting_manager')) else self.sudo()
        if not target.virtual_room_id:
            raise UserError(_("Please select a Virtual Room first."))
        
        provider = getattr(target.virtual_room_id, 'provider', 'zoom')
        
        if provider == 'zoom':
            target._logic_generate_zoom()
        elif provider == 'google_meet':
            target._logic_generate_google_meet()
        elif provider == 'teams':
            target._logic_generate_teams()
        else:
            target._logic_generate_manual_link()

    def _get_zoom_credentials(self, context_room=None):
        """
        Extract Zoom API credentials from virtual room configuration.
        
        Args:
            context_room: virtual.room record (uses self.virtual_room_id if None)
            
        Returns:
            Tuple of (account_id, client_id, client_secret)
            
        Raises:
            UserError: If credentials are missing
        """
        room = (context_room or self.virtual_room_id).sudo()
        if not room:
             raise UserError(_("Virtual Room configuration missing."))
             
        account_id = room.zoom_account_id
        client_id = room.zoom_client_id
        client_secret = room.zoom_client_secret

        if not account_id or not client_id or not client_secret:
            raise UserError(_("Zoom Credentials (Account/Client/Secret) missing for room %s.") % room.name)    
        return account_id, client_id, client_secret

    def _get_zoom_access_token(self, context_room=None):
        """
        Obtain OAuth access token from Zoom API.
        
        Args:
            context_room: virtual.room record with credentials
            
        Returns:
            Access token string
            
        Raises:
            UserError: If authentication fails
        """
        account_id, client_id, client_secret = self._get_zoom_credentials(context_room)
        url = f"https://zoom.us/oauth/token?grant_type=account_credentials&account_id={account_id}"
        try:
            response = requests.post(url, auth=HTTPBasicAuth(client_id, client_secret), timeout=30)
            response.raise_for_status()
            return response.json()['access_token']
        except Exception as e:
            _logger.error("Zoom Auth Error: %s", e)
            raise UserError(_("Zoom connection failed: %s") % e)

    def _get_zoom_headers(self, context_room=None):
        """
        Build HTTP headers with Zoom OAuth token for API requests.
        
        Args:
            context_room: virtual.room record with credentials
            
        Returns:
            Dictionary of HTTP headers
        """
        token = self._get_zoom_access_token(context_room)
        return {'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}

    def _logic_generate_zoom(self):
        """
        Create a new Zoom meeting via Zoom API.
        
        Uses creator's timezone for meeting scheduling (virtual meeting context).
        Automatically maps unsupported timezones to Zoom-compatible equivalents.
        
        Raises:
            UserError: If meeting link already exists or API call fails
        """
        # Refresh record to get latest data from database
        self.invalidate_cache()
        
        if self.zoom_id:
            raise UserError(_("Meeting Link already exists! If you want to regenerate, please save the form first to clear the old link."))

        duration_seconds = (self.end_date - self.start_date).total_seconds()
        duration_minutes = int(duration_seconds / 60)

        # Use creator timezone for virtual meeting scheduling
        tz_name = self.host_user_id.tz or self.create_uid.tz or 'UTC'
        zoom_tz = self._get_zoom_supported_timezone(tz_name)

        url = "https://api.zoom.us/v2/users/me/meetings"
        headers = self._get_zoom_headers() 
        
        start_time_utc = self.start_date.strftime('%Y-%m-%dT%H:%M:%SZ')
        
        payload = {
            "topic": self.subject,
            "type": 2, 
            "start_time": start_time_utc,
            "duration": duration_minutes,
            "timezone": zoom_tz, 
            "settings": {
                "host_video": True,
                "participant_video": True,
                "auto_recording": "cloud"
            }
        }
        
        try:
            res = requests.post(url, headers=headers, json=payload, timeout=30)
            res.raise_for_status()
            zoom_response = res.json()
        except Exception as e:
            raise UserError(_("Failed to create Zoom meeting: %s") % e)

        join_url = zoom_response.get('join_url', '')
        meeting_id = str(zoom_response.get('id', ''))
        password = zoom_response.get('password', '')

        self.write({
            'zoom_id': meeting_id,
            'zoom_link': join_url,
            'zoom_start_url': zoom_response.get('start_url', ''),
        })

        self._generate_invitation_text("Zoom Meeting", join_url, meeting_id, password, zoom_tz)
        
        self.message_post(body=f"Zoom Meeting Created ({zoom_tz}): <a href='{join_url}' target='_blank'>{join_url}</a>")

    def _get_google_meet_credentials(self, context_room=None):
        """
        Extract Google Meet API credentials from virtual room configuration.
        
        Args:
            context_room: virtual.room record (uses self.virtual_room_id if None)
            
        Returns:
            Tuple of (project_id, client_email, private_key)
            
        Raises:
            UserError: If credentials are missing
        """
        room = (context_room or self.virtual_room_id).sudo()
        if not room:
            raise UserError(_("Virtual Room configuration missing."))
        
        project_id = room.google_project_id
        client_email = room.google_client_email
        private_key = room.google_private_key

        if not project_id or not client_email or not private_key:
            raise UserError(_("Google Meet Credentials (Project ID / Client Email / Private Key) missing for room %s.") % room.name)
        
        return project_id, client_email, private_key

    def _get_google_meet_access_token(self, context_room=None):
        """
        Generate OAuth access token from Google service account credentials.
        
        Args:
            context_room: virtual.room record with credentials
            
        Returns:
            Access token string
            
        Raises:
            UserError: If authentication fails
        """
        project_id, client_email, private_key = self._get_google_meet_credentials(context_room)
        
        # Clean input - remove all whitespace issues
        raw_input = private_key.strip()
        
        # Try multiple parsing strategies
        private_key_str = None
        
        # Strategy 1: Check if it already starts with -----BEGIN (direct key paste)
        if raw_input.startswith('-----BEGIN'):
            private_key_str = raw_input
        else:
            # Strategy 2: Try to find private_key field using regex (works even with broken JSON)
            import re
            
            # Pattern 1: Look for "private_key":"-----BEGIN...-----END PRIVATE KEY-----"
            pattern1 = r'"private_key"\s*[:=]\s*"(-----BEGIN[^"]*-----END PRIVATE KEY-----)"'
            match = re.search(pattern1, raw_input, re.DOTALL)
            
            if match:
                private_key_str = match.group(1)
            else:
                # Pattern 2: More flexible - look for anything between -----BEGIN and -----END
                pattern2 = r'(-----BEGIN PRIVATE KEY-----.*?-----END PRIVATE KEY-----)'
                match = re.search(pattern2, raw_input, re.DOTALL)
                
                if match:
                    private_key_str = match.group(1)
                else:
                    raise UserError(_(
                        "Cannot find valid private key. Please:\n"
                        "1. Open the JSON file with a text editor\n"
                        "2. Find the 'private_key' field\n"
                        "3. Copy ONLY the value from -----BEGIN PRIVATE KEY----- to -----END PRIVATE KEY-----\n"
                        "4. Paste it here"
                    ))
        
        # Clean the extracted key
        private_key_str = private_key_str.strip()
        
        # Replace escaped newlines (\\n becomes actual newline)
        private_key_str = private_key_str.replace('\\n', '\n')
        
        # Final validation
        if not private_key_str.startswith('-----BEGIN'):
            raise UserError(_("Private key extraction failed. Start: %s") % private_key_str[:50])
        
        # Create JWT token
        from datetime import datetime, timedelta
        
        now = datetime.utcnow()
        exp = now + timedelta(seconds=3600)
        
        header = {'alg': 'RS256', 'typ': 'JWT'}
        payload = {
            'iss': client_email,
            'scope': 'https://www.googleapis.com/auth/calendar',
            'aud': 'https://oauth2.googleapis.com/token',
            'exp': int(exp.timestamp()),
            'iat': int(now.timestamp())
        }
        
        # Encode JWT
        import base64
        header_b64 = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        message = f"{header_b64}.{payload_b64}"
        
        # Sign JWT with private key
        try:
            from cryptography.hazmat.primitives import hashes, serialization
            from cryptography.hazmat.primitives.asymmetric import padding
            from cryptography.hazmat.backends import default_backend
            
            # Convert string to bytes
            private_key_bytes = private_key_str.encode('utf-8')
            
            private_key_obj = serialization.load_pem_private_key(
                private_key_bytes,
                password=None,
                backend=default_backend()
            )
            
            signature = private_key_obj.sign(
                message.encode(),
                padding.PKCS1v15(),
                hashes.SHA256()
            )
            
            signature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip('=')
            jwt_token = f"{message}.{signature_b64}"
        except Exception as e:
            _logger.error("JWT signing failed: %s", e)
            raise UserError(_("Failed to generate JWT token: %s") % e)
        
        # Exchange JWT for access token
        url = 'https://oauth2.googleapis.com/token'
        payload_token = {
            'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            'assertion': jwt_token
        }
        
        try:
            response = requests.post(url, data=payload_token, timeout=30)
            response_data = response.json()
            
            # Log full response for debugging
            _logger.info("Google OAuth Response: %s", response_data)
            
            if response.status_code != 200:
                error_msg = response_data.get('error', 'Unknown error')
                error_desc = response_data.get('error_description', '')
                raise UserError(_(
                    "Google authentication failed!\n\n"
                    "Error: %s\n"
                    "Description: %s\n\n"
                    "Please check:\n"
                    "1. APIs are enabled (Calendar API & Meet API)\n"
                    "2. Service account has correct permissions\n"
                    "3. Private key is correct"
                ) % (error_msg, error_desc))
            
            if 'access_token' not in response_data:
                raise UserError(_(
                    "No access_token in Google response.\n\n"
                    "Response: %s\n\n"
                    "This usually means the service account doesn't have proper permissions."
                ) % str(response_data))
            
            return response_data['access_token']
        except requests.exceptions.RequestException as e:
            _logger.error("Google Auth Request Error: %s", e)
            raise UserError(_("Failed to connect to Google: %s") % str(e))
        except UserError:
            raise
        except Exception as e:
            _logger.error("Google Auth Error: %s", e)
            raise UserError(_("Google authentication failed: %s") % str(e))

    def _logic_generate_google_meet(self):
        """
        Use static Google Meet link from Virtual Room configuration.
        
        Simple approach: reuse the permanent Google Meet link provided by user.
        No API calls required - just assign the static link to the meeting.
        
        Raises:
            UserError: If meeting link already exists or static link not configured
        """
        # Refresh record to get latest data from database
        self.invalidate_cache()
        
        if self.zoom_id:
            raise UserError(_("Meeting Link already exists! If you want to regenerate, please save the form first to clear the old link."))

        room = self.virtual_room_id.sudo()
        
        if not room.static_link:
            raise UserError(_(
                "Google Meet link not configured!\n\n"
                "Please configure a permanent Google Meet link in the Virtual Room settings:\n"
                "1. Go to meet.google.com\n"
                "2. Create a meeting for later\n"
                "3. Copy the link\n"
                "4. Paste it in Virtual Room configuration"
            ))
        
        meet_link = room.static_link.strip()
        
        # Validate link format
        if not meet_link.startswith('http'):
            meet_link = 'https://' + meet_link
        
        self.write({
            'zoom_id': 'Google Meet',
            'zoom_link': meet_link,
            'zoom_start_url': meet_link,
        })
        
        self._generate_invitation_text("Google Meet", meet_link)
        self.message_post(body=f"Google Meet Link Assigned: <a href='{meet_link}' target='_blank'>{meet_link}</a>")

    def _get_teams_token(self):
        """
        Obtain OAuth token from Microsoft Azure AD for Teams API access.
        
        Returns:
            Access token string
            
        Raises:
            UserError: If credentials missing or authentication fails
        """
        room = self.virtual_room_id.sudo()
        tenant_id = room.zoom_account_id
        client_id = room.zoom_client_id
        client_secret = room.zoom_client_secret

        if not tenant_id or not client_id or not client_secret:
            raise UserError(_("For Teams, please fill: Account ID (Tenant), Client ID, and Secret."))

        url = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
        payload = {
            'grant_type': 'client_credentials',
            'client_id': client_id,
            'client_secret': client_secret,
            'scope': 'https://graph.microsoft.com/.default'
        }
        
        try:
            res = requests.post(url, data=payload, timeout=30)
            res.raise_for_status()
            return res.json().get('access_token')
        except Exception as e:
             raise UserError(_("Failed to login to Microsoft Azure: %s") % e)

    def _logic_generate_teams(self):
        """
        Create a new Microsoft Teams meeting via Microsoft Graph API.
        
        Requires:
        - Azure AD tenant ID, client ID, and client secret in virtual room config
        - Valid host email address
        
        Raises:
            UserError: If credentials missing, user not found, or API call fails
        """
        # Refresh record to get latest data from database
        self.invalidate_cache()
        
        if self.zoom_id:
            raise UserError(_("Meeting Link already exists! If you want to regenerate, please save the form first to clear the old link."))

        token = self._get_teams_token()
        room = self.virtual_room_id.sudo()
        host_email = room.email or self.env.user.email
        if not host_email:
             raise UserError(_("Host Email required for Teams Meeting."))

        try:
            user_url = f"https://graph.microsoft.com/v1.0/users/{host_email}"
            user_res = requests.get(user_url, headers={'Authorization': 'Bearer ' + token}, timeout=30)
            if user_res.status_code != 200:
                 raise UserError(_("User with email %s not found in Azure AD.") % host_email)
            azure_user_id = user_res.json().get('id')
        except Exception as e:
            raise UserError(_("Failed to find Azure user: %s") % e)

        create_url = f"https://graph.microsoft.com/v1.0/users/{azure_user_id}/onlineMeetings"
        
        start_dt = self.start_date.isoformat() + "Z" 
        end_dt = self.end_date.isoformat() + "Z"   
        
        payload = {
            "startDateTime": start_dt,
            "endDateTime": end_dt,
            "subject": self.subject,
        }

        try:
            res = requests.post(create_url, headers={'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json'}, json=payload, timeout=30)
            res.raise_for_status()
            data = res.json()
            join_url = data.get('joinWebUrl')
            
            self.write({
                'zoom_id': 'Microsoft Teams', 
                'zoom_link': join_url,
                'zoom_start_url': join_url,
            })
            
            self._generate_invitation_text("Microsoft Teams", join_url)
            self.message_post(body=f"Teams Meeting Created: <a href='{join_url}' target='_blank'>Join Teams</a>")

        except Exception as e:
            raise UserError(_("Failed to create Teams meeting: %s") % e)

    def _logic_generate_manual_link(self):
        raise UserError(_("Provider logic not implemented yet."))

    def _generate_invitation_text(self, provider_name, url, mid=False, pwd=False, tz_info=False):
        """
        Generate invitation text for meeting.
        
        Args:
            provider_name: Name of the meeting provider (Zoom/Teams/Google Meet)
            url: Meeting join URL
            mid: Meeting ID (optional, provider-specific)
            pwd: Password (IGNORED for security - not included in invitation)
            tz_info: Timezone information string (optional)
            
        Security Note: 
            Password parameter is intentionally ignored and never included in invitation text.
            Users receive passwords through secure provider notification channels only.
        """
        text = (
            f"Topic: {self.subject}\n"
            f"Time: {self.start_date} (UTC)\n"
        )
        if tz_info:
             text += f"Timezone Reference: {tz_info}\n"

        text += f"\nJoin {provider_name}\n{url}\n\n"
        
        if mid and mid != 'Google Meet' and mid != 'Microsoft Teams':
            text += f"Meeting ID: {mid}\n"
        # Password is NOT included for security reasons
        self.write({'zoom_invitation': text})

    def action_get_ai_summary(self):
        """
        Fetch AI-generated meeting summary from Zoom API.
        
        Only available for Zoom meetings with AI summary feature enabled.
        Summary must be generated by Zoom after meeting concludes.
        
        Raises:
            UserError: If provider is not Zoom, no meeting ID, or summary unavailable
        """
        self.ensure_one()
        if not self._can_shared_action():
            raise UserError(_("You are not allowed to generate AI summaries."))

        target = self if (self.create_uid == self.env.user or self.env.user.has_group('meeting_rooms.group_meeting_manager')) else self.sudo()
        provider = getattr(target.virtual_room_id, 'provider', 'zoom')
        if provider != 'zoom':
            raise UserError(_("AI Summary only available for Zoom."))

        if not target.zoom_id:
            raise UserError(_("No Meeting ID found."))
        
        new_summary = target._logic_fetch_formatted_summary(target.zoom_id)
        if not new_summary:
            raise UserError(_("Failed to fetch summary. Meeting might not have AI Summary enabled or is not finished yet."))

        header_style = "border-top: 2px solid #00A09D; margin-top: 20px; padding-top: 10px; color: #00A09D;"
        divider = f"<div style='{header_style}'><h3>âœ¨ Meeting AI Summary Result</h3></div>"
        target.write({'ai_summary': divider + new_summary})

    def _logic_fetch_formatted_summary(self, mid):
        """
        Fetch and format Zoom AI summary with fallback to past meeting UUID.
        
        Args:
            mid: Zoom meeting ID
            
        Returns:
            HTML-formatted summary string or False if not found
        """
        content = self._try_fetch_summary(mid)
        if not content:
            uuid = self._find_past_meeting_uuid(mid)
            if uuid:
                encoded_uuid = urllib.parse.quote(urllib.parse.quote(uuid, safe=''), safe='')
                content = self._try_fetch_summary(encoded_uuid)
        return content

    def _try_fetch_summary(self, mid):
        """
        Attempt to fetch Zoom AI summary for a meeting.
        
        Args:
            mid: Zoom meeting ID or UUID
            
        Returns:
            HTML-formatted summary string or False if summary not available
        """
        url = f"https://api.zoom.us/v2/meetings/{mid}/meeting_summary"
        try:
            res = requests.get(url, headers=self._get_zoom_headers(), timeout=30)
            if res.status_code != 200:
                _logger.error("Zoom API Error: Status %s - Body: %s", res.status_code, res.text)
                return False

            data = res.json()
            html_content = ""
            title = data.get('summary_title')
            if title: html_content += f"<h2>{title}</h2>"
            overview = data.get('summary_overview')
            if overview:
                html_content += (f"<div style='background-color:#f8f9fa; padding:15px; margin-bottom: 20px;'>"
                                 f"<strong style='color:#00A09D;'>Quick Recap:</strong><br/>{overview}</div>")
            
            details = data.get('summary_details', [])
            if details:
                html_content += "<hr/><h4>ðŸ“ Detailed Summary:</h4>"
                for item in details:
                    label = item.get('label') or 'Topic'
                    summary_text = item.get('summary', '')
                    if isinstance(summary_text, list): summary_text = " ".join(summary_text)
                    html_content += (f"<div style='margin-bottom: 15px;'><strong style='font-size: 1.1em; color: #2C3E50;'>{label}</strong>"
                                     f"<p>{summary_text}</p></div>")
            return html_content
        except Exception as e:
            _logger.error("Zoom Summary Exception: %s", e)
            return False

    def _find_past_meeting_uuid(self, mid):
        """
        Find UUID of the most recent past meeting instance.
        
        Used for fetching AI summaries which require UUID instead of meeting ID.
        
        Args:
            mid: Zoom meeting ID
            
        Returns:
            Meeting UUID string or False if not found
        """
        url = f"https://api.zoom.us/v2/past_meetings/{mid}/instances"
        try:
            res = requests.get(url, headers=self._get_zoom_headers(), timeout=30)
            if res.status_code == 200 and res.json().get('meetings'):
                return res.json()['meetings'][-1].get('uuid')
        except Exception:
            return False
        return False

    def _get_alarm_id(self):
        """
        Get calendar alarm/reminder ID for this meeting.
        
        Returns:
            Alarm ID if configured, otherwise first available alarm, or False
        """
        self.ensure_one()
        if self.calendar_alarm:
            return self.calendar_alarm.id
        alarm = self.env['calendar.alarm'].search([], limit=1)
        return alarm.id if alarm else False

    def _sync_rooms_from_event(self):
        """
        Synchronize meeting.rooms records to match current event configuration.
        
        This method:
        1. Creates or updates meeting.rooms records for each location
        2. Cancels meeting.rooms for removed locations
        3. Preserves existing records when possible
        
        Only processes confirmed meetings (state='confirm').
        
        Context:
            skip_event_sync: Prevents infinite recursion
            skip_booking_check: Bypasses double-booking validation
            skip_readonly_check: Allows system to modify readonly meeting.rooms
        """
        MeetingRooms = self.env['meeting.rooms']
        for ev in self:
            if ev.state != 'confirm':
                continue
            
            existing = MeetingRooms.search([('meeting_event_id', '=', ev.id)])
            by_loc = {r.room_location.id: r for r in existing if r.room_location}
            alarm_id = ev._get_alarm_id()
            keep_ids = []

            for loc in ev.room_location_ids:
                vals = {
                    'meeting_event_id': ev.id,
                    'subject': ev.subject,
                    'name': ev.subject,
                    'room_location': loc.id,
                    'virtual_room_id': ev.virtual_room_id.id, 
                    'start_date': ev.start_date,
                    'end_date': ev.end_date,
                    'description': ev.description,
                    'attendee': [(6, 0, ev.attendee.ids)],
                    'recurrency': ev.recurrency,
                    'rrule_type': ev.rrule_type,
                    'final_date': ev.final_date,
                    'state': 'confirm',
                }

                if alarm_id:
                    vals['calendar_alarm'] = alarm_id

                if loc.id in by_loc:
                    by_loc[loc.id].with_context(skip_event_sync=True, skip_booking_check=True, skip_readonly_check=True).write(vals)
                    keep_ids.append(by_loc[loc.id].id)
                else:
                    new_b = MeetingRooms.with_context(skip_event_sync=True, skip_booking_check=True, skip_readonly_check=True).create(vals)
                    keep_ids.append(new_b.id)

            leftovers = existing.filtered(lambda r: r.id not in keep_ids)
            if leftovers:
                leftovers.with_context(skip_event_sync=True, skip_booking_check=True, skip_readonly_check=True).write({'state': 'cancel'})

    # =========================================================
    # CONSTRAINTS - TRIPLE VALIDATION
    # =========================================================
    @api.constrains('start_date', 'end_date', 'room_location_ids', 'virtual_room_id', 'attendee', 'state')
    def _check_double_booking(self):
        """
        Prevent double booking across three dimensions: locations, virtual rooms, and attendees.
        
        Validation applies only to confirmed meetings and checks for time overlaps:
        1. Physical room location conflicts
        2. Virtual room account conflicts (one Zoom account can't host multiple meetings)
        3. Attendee conflicts (people can't be in two meetings simultaneously)
        
        Context:
            skip_double_booking_check: Bypass all validation (use with caution)
            
        Raises:
            ValidationError: If any conflict is detected
        """
        if self.env.context.get('skip_double_booking_check'):
            return

        for ev in self:
            if ev.state != 'confirm':
                continue

            base_domain = [
                ('id', '!=', ev.id),                
                ('state', '=', 'confirm'), 
                ('start_date', '<', ev.end_date),   
                ('end_date', '>', ev.start_date),   
            ]

            if ev.room_location_ids:
                domain_loc = base_domain + [('room_location_ids', 'in', ev.room_location_ids.ids)]
                conflict_loc = self.search(domain_loc, limit=1)
                if conflict_loc:
                    clashed_rooms = set(ev.room_location_ids.mapped('name')) & set(conflict_loc.room_location_ids.mapped('name'))
                    raise ValidationError(
                        f"LOCATION CLASH!\n"
                        f"Room {', '.join(clashed_rooms)} is already booked for meeting '{conflict_loc.subject}'."
                    )

            if ev.virtual_room_id:
                domain_virtual = base_domain + [('virtual_room_id', '=', ev.virtual_room_id.id)]
                conflict_virtual = self.search(domain_virtual, limit=1)
                if conflict_virtual:
                    raise ValidationError(
                        f"VIRTUAL ROOM CLASH!\n"
                        f"Virtual Account '{ev.virtual_room_id.name}' is already used for meeting '{conflict_virtual.subject}'."
                    )

            if ev.attendee:
                domain_user = base_domain + [('attendee', 'in', ev.attendee.ids)]
                conflict_user = self.search(domain_user, limit=1)
                if conflict_user:
                    busy_people = set(ev.attendee.mapped('name')) & set(conflict_user.attendee.mapped('name'))
                    if busy_people:
                        raise ValidationError(
                            f"ATTENDEE CLASH!\n"
                            f"The following people: {', '.join(busy_people)} "
                            f"already have another meeting ('{conflict_user.subject}')."
                        )

    # ==========================
    # ICS / CALENDAR GENERATION (FIXED & ROBUST)
    # ==========================
    def create_calendar_web(self):
        """
        Generate ICS calendar file and send email invitation to attendees.
        
        Creates RFC 5545 compliant iCalendar file with:
        - Proper timezone handling with DST support
        - VTIMEZONE blocks for calendar client compatibility
        - Attendee list with RSVP tracking
        - Reminder/alarm configuration
        - Virtual meeting links in description
        
        Returns:
            Action dictionary to download ICS file
        """
        self.ensure_one()
        rec = self
        
        # 1. Setup time and location data (using helper to avoid duplication)
        local_times = rec._compute_local_times()
        tz_name = local_times['tz_name']
        tz_offset_str = local_times['tz_offset_str']
        
        loc_name = ", ".join(rec.room_location_ids.mapped('name')) if rec.room_location_ids else "Virtual"
        
        formatted_start_time = local_times['formatted_date']
        start_time_hours = local_times['start_time_hours']
        end_time_hours = local_times['end_time_hours']
        
        local_start = local_times['local_start']
        local_end = local_times['local_end']
        create_time = rec.create_date.astimezone(local_times['tz'])

        # 2. Build Description & Link
        raw_desc = rec.description or ''
        description_text = raw_desc.replace('\n', '\\n')
        
        display_location = loc_name
        if rec.zoom_link:
            display_location += " (Online Meeting Available)"
            description_text += f"\\n\\nJoin Link: {rec.zoom_link}"
            if rec.zoom_id and rec.zoom_id != 'Google Meet' and rec.zoom_id != 'Microsoft Teams':
                description_text += f"\\nMeeting ID: {rec.zoom_id}"
        elif rec.virtual_room_id:
            display_location += f" (Virtual: {rec.virtual_room_id.name})"

        # 3. Build ICS Line-by-Line (Robust against whitespace issues)
        lines = []
        lines.append("BEGIN:VCALENDAR")
        lines.append("VERSION:2.0")
        lines.append("PRODID:-//Odoo Meeting Rooms//EN")
        lines.append("CALSCALE:GREGORIAN")
        lines.append("METHOD:REQUEST")
        
        lines.append("BEGIN:VTIMEZONE")
        lines.append(f"TZID:{tz_name}")
        lines.append(f"X-LIC-LOCATION:{tz_name}")
        lines.append("BEGIN:STANDARD")
        lines.append("DTSTART:19700101T000000")
        lines.append(f"TZOFFSETFROM:{tz_offset_str}")
        lines.append(f"TZOFFSETTO:{tz_offset_str}")
        lines.append(f"TZNAME:{tz_name}")
        lines.append("END:STANDARD")
        lines.append("END:VTIMEZONE")
        
        lines.append("BEGIN:VEVENT")
        lines.append(f"UID:meeting_event_{rec.id}")
        lines.append(f"SEQUENCE:{rec.version}")
        lines.append(f"SUMMARY:{rec.subject}")
        lines.append(f"DTSTAMP:{create_time.strftime('%Y%m%dT%H%M%S')}")
        lines.append(f"DTSTART;TZID={tz_name}:{local_start.strftime('%Y%m%dT%H%M%S')}")
        lines.append(f"DTEND;TZID={tz_name}:{local_end.strftime('%Y%m%dT%H%M%S')}")
        lines.append(f"LOCATION:{display_location}")
        lines.append(f"DESCRIPTION:{description_text}")
        lines.append(f'ORGANIZER;PARTSTAT=ACCEPTED;CN="{rec.create_uid.display_name}":mailto:{rec.create_uid.email}')
        
        # Add Attendees to ICS
        for user in rec.attendee:
            if user.email:
                lines.append(f'ATTENDEE;ROLE=REQ-PARTICIPANT;RSVP=TRUE;CN="{user.display_name}":mailto:{user.email}')
        
        if rec.guest_partner_id and rec.guest_partner_id.email:
             lines.append(f'ATTENDEE;ROLE=REQ-PARTICIPANT;RSVP=TRUE;CN="{rec.guest_partner_id.name}":mailto:{rec.guest_partner_id.email}')

        # Alarm
        reminder = int(rec.calendar_alarm.duration) if rec.calendar_alarm and rec.calendar_alarm.duration else 15
        lines.append("BEGIN:VALARM")
        lines.append(f"TRIGGER:-PT{reminder}M")
        lines.append("ACTION:DISPLAY")
        lines.append("DESCRIPTION:Reminder")
        lines.append("END:VALARM")
        
        lines.append("END:VEVENT")
        lines.append("END:VCALENDAR")

        # Join lines with strict CRLF (Standard for ICS)
        ics_content = "\r\n".join(lines)
        
        filename = f"{rec.subject}.ics"
        encoded_ics = base64.b64encode(ics_content.encode('utf-8'))
        
        # Save Attachment
        Attachment = self.env['ir.attachment'].sudo()
        existing_att = Attachment.search([
            ('res_model', '=', 'meeting.event'),
            ('res_field', '=', 'calendar_file'),
            ('res_id', '=', rec.id)
        ])
        if existing_att:
            existing_att.unlink()
            
        attachment = Attachment.create({
            'name': filename,
            'type': 'binary',
            'res_model': 'meeting.event',
            'res_field': 'calendar_file',
            'res_id': rec.id,
            'datas': encoded_ics,
            'public': True
        })

        # ========================================================
        # SEND EMAIL LOGIC
        # ========================================================
        recipients = [rec.create_uid.email] 
        for user in rec.attendee:
            if user.email:
                recipients.append(user.email)
        
        if rec.guest_partner_id and rec.guest_partner_id.email:
            recipients.append(rec.guest_partner_id.email)

        if rec.guest_emails:
            extra_emails = [e.strip() for e in re.split(r'[;\n,]+', rec.guest_emails) if e.strip()]
            recipients.extend(extra_emails)

        recipients_email = ",".join(filter(None, list(set(recipients))))

        virtual_room_info = ""
        if rec.zoom_link:
             virtual_room_info = f"<br/><br/><b>Online Meeting:</b> <a href='{rec.zoom_link}' target='_blank'>Click to Join</a>"
        elif rec.virtual_room_id:
            virtual_room_info = f"<br/>(Virtual Room: {rec.virtual_room_id.name})"

        if recipients_email:
            email_body = f"""
            <div style="font-family: sans-serif;">
                Hi Team & Guest,<br/><br/>
                <b>{rec.create_uid.name}</b> has invited you to the "{rec.subject}" meeting<br/><br/>
                <table border="0" style="background-color: #f9f9f9; padding: 10px; border-radius: 5px;">
                    <tbody>
                        <tr><td style="width:80px;"><b>Date</b></td><td>: {formatted_start_time}</td></tr>
                        <tr><td><b>Time</b></td><td>: {start_time_hours} - {end_time_hours} ({tz_name})</td></tr>
                        <tr><td><b>Location</b></td><td>: {loc_name} {virtual_room_info}</td></tr>
                    </tbody>
                </table>
                <br/>
                Please <b>download the attachment</b> to save this to your calendar.<br/><br/>
            </div>
            """
            
            mail_values = {
                'subject': f"Invitation: {rec.subject}",
                'email_from': rec.create_uid.email_formatted,
                'email_to': recipients_email,
                'body_html': email_body,
                'attachment_ids': [(4, attachment.id)]
            }
            mail = self.env['mail.mail'].sudo().create(mail_values)
            mail.send()
            
            # Log email activity
            rec.message_post(body=f"Email Invitation sent to: {recipients_email}")

        return {
            'type': 'ir.actions.act_url',
            'url': f'/web/content/{attachment.id}?download=true',
            'target': 'self',
        }

    # ==========================
    # ACTION CANCEL (DELETE ZOOM & RESET FIELDS)
    # ==========================
    def action_cancel(self):
        """
        Cancel meeting event and clean up associated resources.
        
        This action:
        1. Security check (only creator or admin can cancel)
        2. Deletes Zoom meeting from server (if exists)
        3. Posts cancellation message to chatter
        4. Deletes all activity notifications
        5. Cancels all child meeting.rooms records
        6. Resets all virtual meeting fields
        7. Changes state to 'cancel'
        """
        # === SECURITY CHECK FIRST (BEFORE TOUCHING ZOOM) ===
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        for ev in self:
            if ev.create_uid != self.env.user and not is_manager:
                raise UserError(_(
                    f"ACCESS DENIED!\n\n"
                    f"You cannot cancel this meeting.\n"
                    f"Only the creator ({ev.create_uid.name}) or a Meeting Administrator can cancel meetings."
                ))
        # ====================================================
        
        MeetingRooms = self.env['meeting.rooms']
        for ev in self:
            # 1. Delete Zoom Meeting from Server (only after security check passed)
            if ev.zoom_id and ev.virtual_room_id and ev.virtual_room_id.provider == 'zoom':
                ev._logic_delete_zoom_meeting(ev.zoom_id, context_room=ev.virtual_room_id)

            # 2. Post cancellation message
            loc_name = ", ".join(ev.room_location_ids.mapped('name')) or "Virtual"
            msg_body = f"Meeting <b>{ev.subject}</b> from {ev.start_date} to {ev.end_date} in <b>{loc_name}</b> Is Cancelled"
            ev.message_post(body=msg_body)

            # 3. Delete all activities
            existing_activities = self.env['mail.activity'].search([
                ('res_id', '=', ev.id),
                ('res_model', '=', 'meeting.event')
            ])
            existing_activities.unlink()

            # 4. Cancel child meeting.rooms records
            rooms = MeetingRooms.search([('meeting_event_id', '=', ev.id)])
            if rooms:
                rooms.with_context(skip_event_sync=True, skip_booking_check=True, skip_readonly_check=True).write({'state': 'cancel'})
            
            # 5. Cancel event and reset all virtual meeting fields
            ev.write({
                'state': 'cancel',
                'zoom_id': False,
                'zoom_link': False,
                'zoom_start_url': False,
                'zoom_invitation': False,
                'ai_summary': False
            })
        return True

    def action_draft(self):
        """
        Reset meeting event to draft state.
        
        Also resets all associated meeting.rooms records to draft.
        """
        MeetingRooms = self.env['meeting.rooms']
        for ev in self:
            rooms = MeetingRooms.search([('meeting_event_id', '=', ev.id)])
            if rooms:
                rooms.with_context(skip_event_sync=True, skip_booking_check=True, skip_readonly_check=True).write({'state': 'draft'})
            ev.write({'state': 'draft'})
        return True

    # ==========================
    # CRON JOB HANDLER
    # ==========================
    @api.model
    def _cron_auto_delete_activities(self):
        """
        Scheduled job to delete stale activity notifications.
        
        Automatically removes activities with deadlines before today for both
        meeting.event and meeting.rooms models to keep activity list clean.
        
        This method is called by Odoo cron scheduler (configured in data/cron_job.xml).
        """
        # Delete stale activities for meeting.event (parent)
        activities_event = self.env['mail.activity'].search([
            ('res_model', '=', 'meeting.event'),
            ('date_deadline', '<', fields.Date.today())
        ])

        # Delete stale activities for meeting.rooms (child)
        activities_rooms = self.env['mail.activity'].search([
            ('res_model', '=', 'meeting.rooms'),
            ('date_deadline', '<', fields.Date.today())
        ])

        # Combine results
        all_activities = activities_event + activities_rooms
        count = len(all_activities)

        if count > 0:
            all_activities.unlink()
            _logger.info(f"CRON JOB: SUCCESSFULLY DELETED {count} Stale Activities.")
        else:
            _logger.info("CRON JOB: No stale activities found.")

    # ==========================
    # SMART BUTTON ACTION
    # ==========================
    def open_zoom_link(self):
        """
        Open virtual meeting link in new browser tab.
        
        Automatically prepends 'https://' if protocol is missing.
        
        Returns:
            Action dictionary to open URL in new window
        """
        self.ensure_one()
        # Auto-fix missing HTTPS protocol
        if self.zoom_link and not self.zoom_link.startswith(('http://', 'https://')):
            return {
                'type': 'ir.actions.act_url',
                'url': 'https://' + self.zoom_link,
                'target': 'new',
            }
        
        if self.zoom_link:
            return {
                'type': 'ir.actions.act_url',
                'url': self.zoom_link,
                'target': 'new',
            }

=== FILE: ./models/meeting_rooms_ext.py ===
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import ValidationError

class MeetingRoomsExt(models.Model):
    _inherit = 'meeting.rooms'

    # Link field
    # =========================================================================
    # NOTE: Updated to use 'cascade' ondelete to ensure child records deleted
    meeting_event_id = fields.Many2one(
        'meeting.event',
        string="Meeting Event Ref",
        index=True,
        ondelete='cascade' 
    )

    # =========================================================
    # Helper methods
    # =========================================================
    def _has_event_model(self):
        """Safety: prevent KeyError if meeting.event model not yet loaded."""
        return 'meeting.event' in self.env.registry.models

    def _linked_event(self):
        self.ensure_one()
        if not self._has_event_model():
            return False
        return self.meeting_event_id if self.meeting_event_id else False

    def _push_rooms_to_event(self, ev):
        """
        Push important data (subject, dates, etc) from meeting.rooms â†’ meeting.event.
        Do NOT push status (state).
        """
        self.ensure_one()
        if not ev:
            return

        vals = {
            'subject': self.subject,
            'start_date': self.start_date,
            'end_date': self.end_date,
            'description': self.description,
            'attendee': [(6, 0, self.attendee.ids)],
        }

        if getattr(self, 'calendar_alarm', False) and self.calendar_alarm:
            vals['calendar_alarm'] = self.calendar_alarm.id

        if getattr(self, 'room_location', False) and self.room_location:
            vals['room_location_ids'] = [(6, 0, [self.room_location.id])]

        # Update event with context flag to prevent infinite loop
        ev.with_context(
            skip_rooms_sync=True,
            skip_event_sync=True,
            skip_booking_check=True,
            skip_availability_check=True,
        ).write(vals)

    def _super_call_or_fallback_state(self, rec, state):
        """
        Safety wrapper to call original button functions.
        Fallback: if function not found, directly update state.
        """
        self.ensure_one()
        try:
            if state == 'confirm':
                return super(MeetingRoomsExt, rec).action_confirm()
            if state == 'cancel':
                return super(MeetingRoomsExt, rec).action_cancel()
            if state == 'draft':
                return super(MeetingRoomsExt, rec).action_draft()
        except Exception:
            # Fallback if original function not found or has error
            # IMPORTANT: Add skip_readonly_check here too for safety
            rec.with_context(skip_booking_check=True, skip_readonly_check=True).write({'state': state})
            return True

    # =========================================================
    # BUTTON OVERRIDES (ISOLATED LOGIC)
    # =========================================================
    
    def action_confirm(self):
        for rec in self:
            rec._super_call_or_fallback_state(rec, 'confirm')
            if not rec.env.context.get('skip_event_sync'):
                ev = rec._linked_event()
                if ev:
                    rec._push_rooms_to_event(ev)
        return True

    def action_cancel(self):
        """Cancel meeting room with security check."""
        # === SECURITY CHECK FIRST ===
        is_manager = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        for rec in self:
            if rec.create_uid != self.env.user and not is_manager:
                raise ValidationError(_(
                    f"ACCESS DENIED!\n\n"
                    f"You cannot cancel this booking.\n"
                    f"Only the creator ({rec.create_uid.name}) or a Meeting Administrator can cancel bookings."
                ))
        # ================================
        
        for rec in self:
            rec._super_call_or_fallback_state(rec, 'cancel')
        return True

    def action_draft(self):
        for rec in self:
            rec._super_call_or_fallback_state(rec, 'draft')
        return True

    # =========================================================
    # WRITE OVERRIDE
    # =========================================================
    def write(self, vals):
        # NOTE: Kita tidak perlu bypass security check disini secara eksplisit
        # karena write ini dipanggil oleh user atau event.
        # Jika dipanggil event, event sudah bawa context.
        # Jika user, maka kena blokir (sesuai keinginan).
        
        res = super(MeetingRoomsExt, self).write(vals)

        if self.env.context.get('skip_event_sync'):
            return res
        if not self._has_event_model():
            return res

        important = {'subject', 'start_date', 'end_date', 'attendee', 'description', 'calendar_alarm', 'room_location'}
        need_push = bool(important.intersection(vals.keys()))
        
        for rec in self:
            ev = rec._linked_event()
            if not ev:
                continue

            if need_push:
                rec._push_rooms_to_event(ev)

        return res

    # =========================================================
    # Legacy data migration (module upgrade)
    # =========================================================
    @api.model
    def action_sync_legacy_data(self):
        """
        Automatically called when module is upgraded via XML.
        Handles old data overlap to prevent errors during installation.
        """
        # Find meeting.rooms records not linked to any event yet
        orphaned_rooms = self.search([('meeting_event_id', '=', False)])
        
        MeetingEvent = self.env['meeting.event']
        linked_count = 0
        created_count = 0
        skipped_count = 0

        for room in orphaned_rooms:
            # 1. Check if corresponding event already exists?
            parent_event = MeetingEvent.search([
                ('subject', '=', room.subject),
                ('start_date', '=', room.start_date),
                ('end_date', '=', room.end_date)
            ], limit=1)

            # Context flags to prevent automation and errors during sync
            # - mail_activity_automation_skip: Disable Odoo's auto activity
            # - skip_double_booking_check: Bypass constraint during legacy sync
            ctx_sync = {
                'force_sync': True, 
                'skip_readonly_check': True,
                'mail_activity_automation_skip': True, 
                'mail_create_nosubscribe': True,
                'skip_double_booking_check': True # Bypass constraint
            }

            if parent_event:
                # CASE A: Link room to existing event
                room.with_context(ctx_sync).write({'meeting_event_id': parent_event.id})
                linked_count += 1
            else:
                # CASE B: Create new parent event
                # NOTE: Manual check for overlap with other events
                # If severe overlap detected, create event in draft state for safety
                
                # Simple overlap detection logic
                overlap = MeetingEvent.search_count([
                    ('start_date', '<', room.end_date),
                    ('end_date', '>', room.start_date),
                    ('state', '=', 'confirm') # Assume only confirmed events are valid
                ])
                
                state_to_set = 'confirm'
                if overlap > 0:
                    state_to_set = 'draft' # Downgrade to draft if conflict
                
                vals = {
                    'subject': room.subject,
                    'start_date': room.start_date,
                    'end_date': room.end_date,
                    'description': room.description,
                    'attendee': [(6, 0, room.attendee.ids)],
                    'state': state_to_set, 
                }
                
                if room.room_location:
                    vals['room_location_ids'] = [(4, room.room_location.id)]
                
                if getattr(room, 'calendar_alarm', False):
                    vals['calendar_alarm'] = room.calendar_alarm.id

                # Create Event Baru dengan Context Aman
                new_event = MeetingEvent.with_context(ctx_sync).create(vals)
                
                # Update Room dengan referensi baru
                room.with_context(ctx_sync).write({'meeting_event_id': new_event.id})
                
                if state_to_set == 'draft':
                    skipped_count += 1
                else:
                    created_count += 1

        if linked_count or created_count or skipped_count:
            print(f"=== [SYNC LEGACY] Linked: {linked_count}, Created: {created_count}, Overlap(Draft): {skipped_count} ===")

=== FILE: ./models/virtual_room.py ===
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import requests
from requests.auth import HTTPBasicAuth

class VirtualRoom(models.Model):
    _name = 'virtual.room'
    _description = 'Virtual Room Configuration'

    name = fields.Char(string="Name", required=True, help="e.g. Corporate Zoom / Teams IT / Google Meet Link")
    active = fields.Boolean(default=True)
    email = fields.Char(string="Host Email", help="Email host for meeting (important for Teams)")

    # === NEW: PROVIDER SELECTION ===
    provider = fields.Selection([
        ('zoom', 'Zoom (API)'),
        ('teams', 'Microsoft Teams (API)'),
        ('google_meet', 'Google Meet (Static Link)'),
    ], string="Provider", default='zoom', required=True)

    # === CREDENTIALS (ZOOM & TEAMS) - ENCRYPTED ===
    # Using ir.model.fields.Secret for encryption at rest
    # Credentials are automatically encrypted by Odoo when saved
    zoom_account_id = fields.Char(string="Account / Tenant ID", groups="base.group_system")
    zoom_client_id = fields.Char(string="Client ID", groups="base.group_system")
    zoom_client_secret = fields.Char(string="Client Secret", groups="base.group_system", password=True)

    # === STATIC LINK (GOOGLE MEET) ===
    static_link = fields.Char(string="Meeting Link", groups="base.group_system", help="Permanent Google Meet link (e.g. https://meet.google.com/xxx-xxxx-xxx)")

    def action_test_connection(self):
        """Test API connection for configured provider"""
        self.ensure_one()
        if self.provider == 'zoom':
            # Test Zoom access token
            if not self.zoom_account_id or not self.zoom_client_id:
                raise UserError(_("Credentials are incomplete. Please provide Account ID and Client ID."))
                
            url = f"https://zoom.us/oauth/token?grant_type=account_credentials&account_id={self.zoom_account_id}"
            try:
                res = requests.post(url, auth=HTTPBasicAuth(self.zoom_client_id, self.zoom_client_secret), timeout=10)
                if res.status_code == 200:
                    token = res.json().get('access_token')
                    return {
                        'type': 'ir.actions.client',
                        'tag': 'display_notification',
                        'params': {
                            'title': 'Connection Successful',
                            'message': 'Zoom API Connected! Token retrieved.',
                            'sticky': False,
                            'type': 'success',
                        }
                    }
                else:
                    raise UserError(f"Zoom Error: {res.text}")
            except Exception as e:
                raise UserError(f"Connection Failed: {str(e)}")
        
        elif self.provider == 'teams':
             # Teams connection test not fully implemented yet
             raise UserError(_("Test Connection for Microsoft Teams is not yet fully implemented."))
        
        elif self.provider == 'google_meet':
             # Google Meet uses static link, no API test required
             return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Information',
                    'message': 'Google Meet uses a static link. No API connection test is required.',
                    'type': 'info',
                }
            }

=== FILE: ./models/booking_link.py ===
# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import uuid
from werkzeug.urls import url_join

class ResUsers(models.Model):
    _inherit = 'res.users'

    # Relasi balik ke booking link
    booking_link_ids = fields.One2many('meeting.booking.link', 'user_id', string="Booking Links")
    
    # Boolean field to indicate if user already has a booking link
    has_booking_link = fields.Boolean(compute='_compute_has_booking_link', store=True)

    @api.depends('booking_link_ids')
    def _compute_has_booking_link(self):
        for user in self:
            # Count booking links for this user
            count = self.env['meeting.booking.link'].search_count([('user_id', '=', user.id)])
            user.has_booking_link = count > 0

class MeetingBookingLink(models.Model):
    _name = 'meeting.booking.link'
    _description = 'Booking Link Configuration'
    _rec_name = 'name'

    _sql_constraints = [
        ('user_id_uniq', 'unique(user_id)', 'This user already has a Booking Link! Cannot create duplicate.')
    ]

    name = fields.Char(string="Link Title", required=True, default="My Booking Link")
    
    user_id = fields.Many2one(
        'res.users', 
        string="Host User", 
        required=True, 
        # default=lambda self: self.env.user,
    )
    
    token = fields.Char("Token", required=True, copy=False, readonly=True, index=True, default=lambda self: self._generate_token())
    active = fields.Boolean(default=True)
    booking_url = fields.Char("Full URL", compute="_compute_url")

    # Helper fields for display and permissions
    is_current_user = fields.Boolean(compute='_compute_permissions')
    is_admin = fields.Boolean(compute='_compute_permissions')

    @api.depends('user_id')
    def _compute_permissions(self):
        # REVISI: Cek Group Meeting Manager, BUKAN System Administrator
        # Sebelumnya: has_group('base.group_system') -> Salah sasaran
        is_admin_user = self.env.user.has_group('meeting_rooms.group_meeting_manager')
        
        for rec in self:
            rec.is_current_user = (rec.user_id == self.env.user)
            rec.is_admin = is_admin_user

    def _generate_token(self):
        return uuid.uuid4().hex[:12]

    @api.depends('token')
    def _compute_url(self):
        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
        for rec in self:
            if rec.token:
                rec.booking_url = url_join(base_url, f"/book/{rec.token}")
            else:
                rec.booking_url = False

    def action_regenerate_token(self):
        for rec in self:
            rec.token = uuid.uuid4().hex[:12]

    @api.model
    def action_open_my_link(self):
        my_link = self.search([('user_id', '=', self.env.user.id)], limit=1)
        if not my_link:
            my_link = self.create({
                'name': f"{self.env.user.name}'s Booking Link",
                'user_id': self.env.user.id
            })
        return {
            'type': 'ir.actions.act_window',
            'name': 'Edit My Booking Link',
            'res_model': 'meeting.booking.link',
            'res_id': my_link.id,
            'view_mode': 'form',
            'target': 'current',
        }

    def init(self):
        """
        This function is automatically called when module is upgraded.
        Purpose: force update has_booking_link field in ResUsers model.
        """
        all_links = self.search([])
        users_with_links = all_links.mapped('user_id')
        
        if users_with_links:
            users_with_links.write({'has_booking_link': True})