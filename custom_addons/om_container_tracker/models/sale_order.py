from odoo import models, fields, api
from odoo.exceptions import AccessError, UserError
import secrets
import logging
import re

_logger = logging.getLogger(__name__)

class SaleOrder(models.Model):
    _inherit = 'sale.order'

    container_number = fields.Char(
        string='Container Number',
        copy=False,
        tracking=True,
        index='btree'  # Issue #7: Database optimization
    )
    access_token = fields.Char(
        string='Tracking Token',
        copy=False,
        readonly=True,
        groups='base.group_system',  # Issue #5: Permission restriction
        index='btree'
    )
    tracking_url = fields.Char(
        string='Tracking Link',
        compute='_compute_tracking_url',
        readonly=True
    )
    token_generated_date = fields.Datetime(
        string='Token Generated',
        readonly=True,
        help='Audit trail'
    )
    token_generated_by = fields.Many2one(
        'res.users',
        string='Token Generated By',
        readonly=True
    )

    _sql_constraints = [
        ('unique_container_token',
         'unique(container_number, access_token)',
         'Container + Token combination must be unique!')
    ]

    @api.depends('container_number', 'access_token')
    def _compute_tracking_url(self):
        base_url = self.env['ir.config_parameter'].sudo().get_param('web.base.url')
        
        for order in self:
            if order.container_number and order.access_token:
                import urllib.parse
                encoded_container = urllib.parse.quote(order.container_number.upper())
                order.tracking_url = f"{base_url}/tracking/container?number={encoded_container}&token={order.access_token}"
            else:
                order.tracking_url = False

    def action_generate_tracking_token(self):
        """Issue #5 & #8: Secure token generation with audit trail"""
        # Allow all internal Odoo users (only block public)
        if self.env.user.id == self.env.ref('base.public_user').id:
            raise AccessError("Public users cannot generate tracking tokens")

        for order in self:
            # Validate container number exists
            if not order.container_number:
                raise UserError(
                    f"Container Number must be filled for {order.name}"
                )
            
            # Validate format (ISO 6346)
            container_pattern = r'^[A-Z]{4}[0-9]{6,7}$'
            if not re.match(container_pattern, order.container_number.upper()):
                raise UserError(
                    f"Invalid Container Number format: {order.container_number}\n"
                    f"Expected: CSNU6184414"
                )

            try:
                # Issue #1: Use secrets for cryptographically secure random
                order.access_token = secrets.token_urlsafe(32)
                order.token_generated_date = fields.Datetime.now()
                order.token_generated_by = self.env.user

                _logger.info(
                    f"Token generated for {order.name}: {order.container_number} "
                    f"by {self.env.user.name}"
                )

            except Exception as e:
                _logger.error(f"Failed to generate token: {str(e)}")
                raise UserError(f"Error generating token: {str(e)}")

    @api.constrains('container_number')
    def _validate_container_number(self):
        """Issue #4: Validate container format"""
        container_pattern = r'^[A-Z]{4}[0-9]{6,7}$'
        
        for record in self:
            if record.container_number:
                if not re.match(container_pattern, record.container_number.upper()):
                    raise UserError(
                        f"Invalid Container Number: {record.container_number}\n"
                        f"Expected format (ISO 6346): 4 letters + 6-7 digits\n"
                        f"Example: CSNU6184414"
                    )

    def action_reset_tracking_token(self):
        """Issue #1: Reset token if compromised"""
        for order in self:
            old_token = order.access_token
            order.action_generate_tracking_token()
            _logger.warning(
                f"Token reset for {order.name} by {self.env.user.name}"
            )